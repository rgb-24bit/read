#+TITLE:      2021

* 目录                                                    :TOC_4_gh:noexport:
- [[#m01][M01]]
- [[#m02][M02]]
- [[#m03][M03]]

* M01
  ☞ [[https://mp.weixin.qq.com/s/AkCFvCiP7md7pKBN6_8pmw][为什么苹果 M1 芯片如此之快？]]
  
  1) M1 不是 CPU，它是一个集成了多个芯片的整体系统
  2) 如今摩尔定律已经失效，通过「快速执行更多指令」来提升 CPU 性能已经很难，因此，我们所能做的只能是「并行执行」尽可能多的指令
  3) 并行执行大量指令的方法有两种：
     + 添加更多 CPU 核心，能够让计算机同时执行更多的任务，但是对于单个任务的性能提升有限，适合云服务
     + 通过乱序执行并行执行更多指令
  4) 为什么 AMD 和英特尔的乱序执行不如 M1？（见原文）

  -----

  ☞ [[https://mp.weixin.qq.com/s/yITNjo_UQi8-OKQNOfGrPw][C++ 服务编译耗时优化原理及实践]]

  1) C/C++ 的特点，头文件会在编译时展开，当大的头文件被频繁引用时，编译时长自然会增加很多。基于这一点，通过工具分析头文件的依赖关系，
     去掉不合理的部分，可以起到优化编译耗时的作用
     
  -----

  ☞ [[https://www.infoq.cn/article/Ov7prhrTiNw6JjhELmh6][4 种主流的 API 架构风格对比-InfoQ]]

  1) 四种 API 架构中接触的较多的是 RESTful 和 RPC，一个对外，一个对内
  2) GraphQL 有过了解，但没有使用过
  3) SOAP 似乎看到过，还以为这种结构都废弃了，但还是有其使用场景
  4) 每种架构都有其适合的场景，不能太过绝对的认为某一个架构由于另一个，同时，业界今年来的飞速发展，新的技术不断出现，
     只能说新的技术有其更适合的特化场景，不能说老技术就没价值了。

     根据业务场景选择适合的技术栈，而不是一味的追求新。

  -----

  ☞ [[https://blog.betacat.io/post/2020/03/a-pattern-for-writing-testable-go-code/][编写可测试 Go 代码的一种模式 - 喵叔没话说]]

  1) Go 语言的特性，或者说风格在部分场景下对于单测并不友好，这时如果一定要追求 100% 的覆盖率，那么，就不得不通过一些手段来替换自己的代码。

     这样的代码很丑，完全为了单测而编写的代码，比如需要测试的代码中存在 package.Func 时。

     另外，代码中存在 if err 也为编写单测带来了巨大的负担。

  2) Go Code Review 就指明了，Go 推荐在需要使用的地方定义接口，而不是先定义接口再去实现。

     Go 接口的实现和结构体的定义是割裂的，在只看到结构体的情况下你并不能知道它实现了什么接口，这时如果还遵循 Java 里面先接口后实现的模式，
     在代码量上来后，反而会为代码的维护和阅读带来额外的负担。

  -----

  ☞ [[https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md][Sizedness in Rust]]

  1) double-width pointer，同时存在指向对象的指针和指向长度的指针

* M02
  ☞ [[https://help.aliyun.com/document_detail/164859.html][自动 SQL 限流 - 数据库自治服务 DAS - 阿里云]]

  1) 对异常 SQL 类型的分类很有道理：
     + 阻塞型 SQL，通过分析实时会话、锁等待和运行中的事务，判断是否存在 DDL 变更、锁等待和大事务等情况。同时分析和判断被影响会话的数量和执行时间，如果被影响的会话比较多或执行时间很长，
       则该异常无需通过限流 SQL 来解决，而是 Kill 异常会话。
     + 资源消耗型 SQL（即烂 SQL），可能 SQL 的并发量不大，但会消耗大量的 CPU、IO 或网络资源，并且会持续不断地提交
     + 流量型 SQL，大量的正常 SQL 在数据库中同时运行，触发数据库的资源瓶颈，导致甚至 KV 类的查询 SQL 的响应时间都出现异常
     + 其他，其他未包含上述 3 种情况的场景
  2) SQL 的特征提取：
     + SQL 模板，将 SQL 文本的具体参数抽象化后的文本。这类 SQL 并发度高都会产生问题，但与具体参数无关，因此特征只需要包含模板特征即可，就是相当于对应的 prepare sql
     + SQL 文本，同一类模板中一些 SQL 执行正常，但另一些执行异常，特征中既要包含 SQL 模板信息，又要包含具体参数信息

  -----
  
  ☞ [[https://mp.weixin.qq.com/s/k9r7XtAq7VnAvyZ2G5Kdgg][你不好奇 CPU 是如何执行任务的？]]

  1) 从 CPU 缓存到 Disk 读取，随机访问延迟从 1ns 到 10ms，也就是说 Disk 读取一次够 CPU 在 L1 Cache 中读取 10_000_000 次了，差了 7 个数量级，
     难怪说异步架构能够提高程序性能，避免 I/O 阻塞，提高 CPU 利用率是很大的提升了。
  2) 多核系统中 Cache Line 大小和实际变量大小的不同可能导致的伪共享问题，之前只知道结构体数据对齐，现在看来，在多核环境下，仅仅是数据宽度对齐可能还不够，
     还需要 Cache Line Size 对齐才能最有效的利用 CPU 缓存。
 
* M03
  ☞ [[https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html][微前端在美团外卖的实践 - 美团技术团队]]

  1) 这边文章是在了解到「微前端」这个陌生的概念后 Google 出来的，因为写过一点前端代码，所以对这些东西的原理还是比较好奇。
  2) 从这篇文章中的东西来看，「微前端」本质上就是利用一个中心化的基座来维护通用的能力，利用路由来匹配子系统，在用户进入相关的子路由后，
     就加载相关子系统代码到前端。
  3) 和「微服务」的模式是比较像的，中心化的基座起到服务发现的作用，而路由对应就是服务名称
  4) 由于前端模式比较特殊，虽然利用「微前端」的模式对不同子系统进行了拆分，单本质上最后所有系统的代码还是会加载到一个页面，因此，
     需要考虑如何解决不同系统代码间代码冲突的问题。即实现一个前端的沙箱，文章 [[https://segmentfault.com/a/1190000038219823][解密微前端：从 qiankun 看沙箱隔离]] 对这个概念有简单的解析。

