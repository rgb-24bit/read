#+TITLE:      json
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#flaskjson][flask.json]]
- [[#初始化模块][初始化模块]]
  - [[#依赖][依赖]]
  - [[#代码][代码]]
- [[#tag-模块][TAG 模块]]
  - [[#依赖-1][依赖]]
  - [[#代码-1][代码]]

* flask.json
  ~flask.json~ 是 ~flask~ 的一个子包， 处理和 ~json~ 相关的数据。

  处理初始化模块以外， 就只有一个 ~tag~ 模块。 同时除了 ~_compat~ 和 ~globals~ 以外， 就没有更多的
  内部依赖了。

  虽然还有一些其他模块的依赖也比较少， 但还是想先到这个模块来取取经， 了解 ~json~ 的处理方法。

* 初始化模块
** 依赖
   首先还是看依赖：
   #+BEGIN_SRC python
     import codecs
     import io
     import uuid
     from datetime import date, datetime
     from flask.globals import current_app, request
     from flask._compat import text_type, PY2

     from werkzeug.http import http_date
     from jinja2 import Markup

     # Use the same json implementation as itsdangerous on which we
     # depend anyways.
     from itsdangerous import json as _json
   #+END_SRC

   有几个不熟悉的模块：
   + codecs: encode 和 decode 相关的一个模块， 可以直接使用 ~codecs.open~ 按指定的编码读取文件
   + uuid: Python 中用于生成通用唯一识别码的模块， 感觉会很有用
   + datetime: 日期时间相关的模块， 知道有这个对象， 但很少用过

   第三方库依赖：
   + werkzeug.http.http_date: 格式化时间以匹配 RFC1123 日期格式

     #+BEGIN_SRC python
       >>> http_date()
       'Thu, 21 Jun 2018 04:10:29 GMT'

       >>> import time
       >>> http_date(time.time())
       'Thu, 21 Jun 2018 04:12:27 GMT'
     #+END_SRC

     + [[http://werkzeug.pocoo.org/docs/0.14/http/#werkzeug.http.http_date][werkzeug.http.http_date]]

   + jinja2.Markup: 可以标记一段字符串为安全的， 使得其转换为 ~HTML~ 字符串时不进行转义。
     或者通过 ~Markup.escape~ 进行转义。 如果一个对象定义了 ~__html__~ 方法， 也可以用 ~Markup~
     进行标记。

     #+BEGIN_SRC python
       >>> Markup("Hello <em>World</em>!")
       Markup(u'Hello <em>World</em>!')
       >>> class Foo(object):
       ...  def __html__(self):
       ...   return '<a href="#">foo</a>'
       ...
       >>> Markup(Foo())
       Markup(u'<a href="#">foo</a>')

       >>> Markup.escape("Hello <em>World</em>!")
       Markup(u'Hello &lt;em&gt;World&lt;/em&gt;!')
     #+END_SRC

   + itsdangerous.json: itsdangerous 的 json 是这样的：
     #+BEGIN_SRC python
       try:
           import simplejson as json
       except ImportError:
           import json
     #+END_SRC

     ~simplejson~ 在 2.6 版本开始就加入标准库了， 这里是对更古老的版本的兼容 @_@

** 代码
   很好奇现在的 ~flask~ 兼容几个版本的 ~Python~:
   #+BEGIN_SRC python
     # Figure out if simplejson escapes slashes.  This behavior was changed
     # from one version to another without reason.
     _slash_escape = '\\/' not in _json.dumps('/')
   #+END_SRC

   好奇当年这里是不是出过 bug (｀・ω・´)
 
   文件编码相关的封装：
   #+BEGIN_SRC python
     def _wrap_reader_for_text(fp, encoding):
         if isinstance(fp.read(0), bytes):
             fp = io.TextIOWrapper(io.BufferedReader(fp), encoding)
         return fp


     def _wrap_writer_for_text(fp, encoding):
         try:
             fp.write('')
         except TypeError:
             fp = io.TextIOWrapper(fp, encoding)
         return fp
   #+END_SRC
   
   这部分的封装涉及到了 ~Python IO~ 的层次结构， 暂时不是清楚相关的内容。

   但是研究了一下， 突然发现， ~io~ 模块在 ~Python2~ 和 ~Python3~ 中的行为是一样的， 输入输出都是 ~Unicode~ 对象。

   这里， ~io.BufferedReader~ 是处理二进制数据的带缓冲的 ~I/O~ 层， ~io.TextIOWrapper~ 是一个编码和解码 Unicode 的文本处理层。

   相关内容： [[http://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p16_add_change_encoding_of_already_open_file.html][python3-cookbook]]
   
   #+BEGIN_SRC python
     class JSONEncoder(_json.JSONEncoder):
         """The default Flask JSON encoder.  This one extends the default simplejson
         encoder by also supporting ``datetime`` objects, ``UUID`` as well as
         ``Markup`` objects which are serialized as RFC 822 datetime strings (same
         as the HTTP date format).  In order to support more data types override the
         :meth:`default` method.
         """

         def default(self, o):
             """Implement this method in a subclass such that it returns a
             serializable object for ``o``, or calls the base implementation (to
             raise a :exc:`TypeError`).
             For example, to support arbitrary iterators, you could implement
             default like this::
                 def default(self, o):
                     try:
                         iterable = iter(o)
                     except TypeError:
                         pass
                     else:
                         return list(iterable)
                     return JSONEncoder.default(self, o)
             """
             if isinstance(o, datetime):
                 return http_date(o.utctimetuple())
             if isinstance(o, date):
                 return http_date(o.timetuple())
             if isinstance(o, uuid.UUID):
                 return str(o)
             if hasattr(o, '__html__'):
                 return text_type(o.__html__())
             return _json.JSONEncoder.default(self, o)


     class JSONDecoder(_json.JSONDecoder):
         """The default JSON decoder.  This one does not change the behavior from
         the default simplejson decoder.  Consult the :mod:`json` documentation
         for more information.  This decoder is not only used for the load
         functions of this module but also :attr:`~flask.Request`.
         """
   #+END_SRC

   可以看一下 ~Json.loads~ 和 ~Json.dumps~ 的参数：
   #+BEGIN_SRC python
     json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)

     dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)
   #+END_SRC

   两个方法函数都有的参数： ~cls~, 分别对应 ~JSONDecoder~ 和 ~JSONEncoder~.

   通过继承和重写这两个类的方法来定义适用于自己的对象的行为。

   这里的代码中， 主要定义了 ~JSONEncoder~ 的行为， 针对的对象类型为 ~datetime~, ~date~ 和
   ~uuid.UUID~ 以及定义了 ~__html__~ 方法的对象。

   可以学习一下。

   #+BEGIN_SRC python
     def _dump_arg_defaults(kwargs):
         """Inject default arguments for dump functions."""
         if current_app:
             bp = current_app.blueprints.get(request.blueprint) if request else None
             kwargs.setdefault(
                 'cls',
                 bp.json_encoder if bp and bp.json_encoder
                     else current_app.json_encoder
             )

             if not current_app.config['JSON_AS_ASCII']:
                 kwargs.setdefault('ensure_ascii', False)

             kwargs.setdefault('sort_keys', current_app.config['JSON_SORT_KEYS'])
         else:
             kwargs.setdefault('sort_keys', True)
             kwargs.setdefault('cls', JSONEncoder)


     def _load_arg_defaults(kwargs):
         """Inject default arguments for load functions."""
         if current_app:
             bp = current_app.blueprints.get(request.blueprint) if request else None
             kwargs.setdefault(
                 'cls',
                 bp.json_decoder if bp and bp.json_decoder
                     else current_app.json_decoder
             )
         else:
             kwargs.setdefault('cls', JSONDecoder)
   #+END_SRC

   构建 ~dump~ 和 ~load~ 的默认参数， 虽然涉及到了一些其他的对象， 但是还是不难看出这两个
   函数的作用的。

   基本流程都是：
   1. 判断当前应用栈的顶部元素是否存在
   2. 判断当前请求栈的顶部元素是否存在
   3. 两个都存在， 根据应用和蓝图的配置确定默认参数
   4. 不存在， 设置确定的默认参数

   除了 ~flask~ 自身提供的 ~JSONDecoder~ 和 ~JSONEncoder~ 对象以外， 用户还可以尽情的定义自己的对象。

   还可以针对不同的蓝图进行配置 (｀・ω・´)
   
   第一次看到自己检测编码：
   #+BEGIN_SRC python
     def detect_encoding(data):
         """Detect which UTF codec was used to encode the given bytes.
         The latest JSON standard (:rfc:`8259`) suggests that only UTF-8 is
         accepted. Older documents allowed 8, 16, or 32. 16 and 32 can be big
         or little endian. Some editors or libraries may prepend a BOM.
         :param data: Bytes in unknown UTF encoding.
         :return: UTF encoding name
         """
         head = data[:4]

         if head[:3] == codecs.BOM_UTF8:
             return 'utf-8-sig'

         if b'\x00' not in head:
             return 'utf-8'

         if head in (codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE):
             return 'utf-32'

         if head[:2] in (codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE):
             return 'utf-16'

         if len(head) == 4:
             if head[:3] == b'\x00\x00\x00':
                 return 'utf-32-be'

             if head[::2] == b'\x00\x00':
                 return 'utf-16-be'

             if head[1:] == b'\x00\x00\x00':
                 return 'utf-32-le'

             if head[1::2] == b'\x00\x00':
                 return 'utf-16-le'

         if len(head) == 2:
             return 'utf-16-be' if head.startswith(b'\x00') else 'utf-16-le'

         return 'utf-8'
   #+END_SRC

   这个东西就涉及到编码相关的内容了， 看不明白， 也不准备看明白。 目前就先用现成的库就足够了。

   比如 [[https://github.com/chardet/chardet][chardet]].

   接下来是几个对 ~json~ 本身方法的一层封装和扩展：
   #+BEGIN_SRC python
     def dumps(obj, **kwargs):
         _dump_arg_defaults(kwargs)
         encoding = kwargs.pop('encoding', None)
         rv = _json.dumps(obj, **kwargs)
         if encoding is not None and isinstance(rv, text_type):
             rv = rv.encode(encoding)
         return rv


     def dump(obj, fp, **kwargs):
         _dump_arg_defaults(kwargs)
         encoding = kwargs.pop('encoding', None)
         if encoding is not None:
             fp = _wrap_writer_for_text(fp, encoding)
         _json.dump(obj, fp, **kwargs)


     def loads(s, **kwargs):
         _load_arg_defaults(kwargs)
         if isinstance(s, bytes):
             encoding = kwargs.pop('encoding', None)
             if encoding is None:
                 encoding = detect_encoding(s)
             s = s.decode(encoding)
         return _json.loads(s, **kwargs)


     def load(fp, **kwargs):
         _load_arg_defaults(kwargs)
         if not PY2:
             fp = _wrap_reader_for_text(fp, kwargs.pop('encoding', None) or 'utf-8')
         return _json.load(fp, **kwargs)
   #+END_SRC

   dump, dumps, load, loads 的源码的理解还是很简单的。

   由于涉及到 ~Python2~ 和 ~Python3~ 的兼容问题， 所以这里的 ~text_type~ 来自于之前的 ~_compat~ 模块。

   其中， ~text_type~ 为 ~unicode~, 而 ~string_type~ 为 ~byte~.

   兼容是真的烦， 理解这一段代码在 ~Python2~ 和 ~Python3~ 下的行为， 有点绕。

   #+BEGIN_SRC python
     def htmlsafe_dumps(obj, **kwargs):
         """Works exactly like :func:`dumps` but is safe for use in ``<script>``
         tags.  It accepts the same arguments and returns a JSON string.  Note that
         this is available in templates through the ``|tojson`` filter which will
         also mark the result as safe.  Due to how this function escapes certain
         characters this is safe even if used outside of ``<script>`` tags.
         The following characters are escaped in strings:
         -   ``<``
         -   ``>``
         -   ``&``
         -   ``'``
         This makes it safe to embed such strings in any place in HTML with the
         notable exception of double quoted attributes.  In that case single
         quote your attributes or HTML escape it in addition.
         .. versionchanged:: 0.10
            This function's return value is now always safe for HTML usage, even
            if outside of script tags or if used in XHTML.  This rule does not
            hold true when using this function in HTML attributes that are double
            quoted.  Always single quote attributes if you use the ``|tojson``
            filter.  Alternatively use ``|tojson|forceescape``.
         """
         rv = dumps(obj, **kwargs) \
             .replace(u'<', u'\\u003c') \
             .replace(u'>', u'\\u003e') \
             .replace(u'&', u'\\u0026') \
             .replace(u"'", u'\\u0027')
         if not _slash_escape:
             rv = rv.replace('\\/', '/')
         return rv


     def htmlsafe_dump(obj, fp, **kwargs):
         """Like :func:`htmlsafe_dumps` but writes into a file object."""
         fp.write(text_type(htmlsafe_dumps(obj, **kwargs)))
   #+END_SRC

   对 html 中一部分特殊字符的处理， 简单直接。

   #+BEGIN_SRC python
     def jsonify(*args, **kwargs):
         indent = None
         separators = (',', ':')

         if current_app.config['JSONIFY_PRETTYPRINT_REGULAR'] or current_app.debug:
             indent = 2
             separators = (', ', ': ')

         if args and kwargs:
             raise TypeError('jsonify() behavior undefined when passed both args and kwargs')
         elif len(args) == 1:  # single args are passed directly to dumps()
             data = args[0]
         else:
             data = args or kwargs

         return current_app.response_class(
             dumps(data, indent=indent, separators=separators) + '\n',
             mimetype=current_app.config['JSONIFY_MIMETYPE']
         )


     def tojson_filter(obj, **kwargs):
         return Markup(htmlsafe_dumps(obj, **kwargs))
   #+END_SRC

   对于 jsonify, 不能同时使用位置参数和关键字参数。

   还是很好理解的一个函数。

   tojson_filter 将 obj 转换为 json 字符串， 同时将 html 特殊字符转义， 然后使用 Markup 标记
   这一段字符串为安全的。

   感觉可以将这个模块的部分内容修改一下收藏。

   这一段的代码的理解有点绕， 换了一个思路， 既然是对 ~json~ 的封装和扩展， 那就看一下对 ~json~ 作了哪些改动即可。

   ~dumps~ 中对参数进行了修改， 设置 ~encoding~ 参数的作用是对返回值进行处理， ~dumps~ 会使用默认的 ~encoding~ 设置。

   也就是说， dumps 的行为与相应环境下的 ~json.dumps~ 的行为基本一致， 除了可以通过 ~encoding~ 设置返回的字符串的编码。

   ~dump~ 也是如此， 处理可以通过 ~encoding~ 来对 ~fp~ 进行封装。

   如果 ~fp~ 类似 ~io.open~ 的 ~file~ 对象， 就可以通过 ~encoding~ 改变编码设置。

   ~Python2~ 的旧 ~open~ 返回的文件对象不能进行封装， 因此这应该是为 ~io.open~ 准备的。

   ~loads~, 会对传入的字符串解码， 然后行为和 ~json.loads~ 基本相同， 一样不能设置 ~encoding~ 参数。

   ~load~, 前面的猜测应该是对的， 如果不是 ~Python2~, 就可以通过 ~encoding~ 参数对文件对象进行一次封装。

   总的来说， 行为和原始的 ~json~ 基本一致， 特殊的是 ~encoding~ 参数不是用于 ~json~ 的序列化与反序列化， 而是用于对序列化前或序列化后的对象
   进行处理。

   感觉差不多理清了， 这里对 ~json~ 的封装和扩展是针对 ~encoding~ 参数进行的， 序列化和反序列化使用默认的 ~encoding~ 参数， 而传入的 ~encoding~ 参数
   用于在序列化前或序列化后的对象进行处理。
   
* TAG 模块
  这个模块的作用文档写的很清楚 [[https://github.com/pallets/flask/blob/1.0/flask/json/tag.py#L6][Tagged JSON]].

** 依赖
   这个模块的依赖就是我比较熟悉的了：
   #+BEGIN_SRC python
     from base64 import b64decode, b64encode
     from datetime import datetime
     from uuid import UUID

     from jinja2 import Markup
     from werkzeug.http import http_date, parse_date

     from flask._compat import iteritems, text_type
     from flask.json import dumps, loads
   #+END_SRC

   + werkzeug.http.parse_date: 相当于是 ~http_date~ 的逆方法， 可以将以下格式的时间转换
     为 ~datetime~ 对象：
     #+BEGIN_EXAMPLE
       Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
       Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
       Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
     #+END_EXAMPLE

** 代码
   这个模块的核心基类：
   #+BEGIN_SRC python
     class JSONTag(object):
         """Base class for defining type tags for :class:`TaggedJSONSerializer`."""

         __slots__ = ('serializer',)

         #: The tag to mark the serialized object with. If ``None``, this tag is
         #: only used as an intermediate step during tagging.
         key = None

         def __init__(self, serializer):
             """Create a tagger for the given serializer."""
             self.serializer = serializer

         def check(self, value):
             """Check if the given value should be tagged by this tag."""
             raise NotImplementedError

         def to_json(self, value):
             """Convert the Python object to an object that is a valid JSON type.
             The tag will be added later."""
             raise NotImplementedError

         def to_python(self, value):
             """Convert the JSON representation back to the correct type. The tag
             will already be removed."""
             raise NotImplementedError

         def tag(self, value):
             """Convert the value to a valid JSON type and add the tag structure
             around it."""
             return {self.key: self.to_json(value)}
   #+END_SRC

   另外一个配合这个类使用的关键类：
   #+BEGIN_SRC python
     class TaggedJSONSerializer(object):
         """Serializer that uses a tag system to compactly represent objects that
         are not JSON types. Passed as the intermediate serializer to
         :class:`itsdangerous.Serializer`.
         The following extra types are supported:
         ,* :class:`dict`
         ,* :class:`tuple`
         ,* :class:`bytes`
         ,* :class:`~flask.Markup`
         ,* :class:`~uuid.UUID`
         ,* :class:`~datetime.datetime`
         """

         __slots__ = ('tags', 'order')

         #: Tag classes to bind when creating the serializer. Other tags can be
         #: added later using :meth:`~register`.
         default_tags = [
             TagDict, PassDict, TagTuple, PassList, TagBytes, TagMarkup, TagUUID,
             TagDateTime,
         ]

         def __init__(self):
             self.tags = {}
             self.order = []

             for cls in self.default_tags:
                 self.register(cls)

         def register(self, tag_class, force=False, index=None):
             """Register a new tag with this serializer.
             :param tag_class: tag class to register. Will be instantiated with this
                 serializer instance.
             :param force: overwrite an existing tag. If false (default), a
                 :exc:`KeyError` is raised.
             :param index: index to insert the new tag in the tag order. Useful when
                 the new tag is a special case of an existing tag. If ``None``
                 (default), the tag is appended to the end of the order.
             :raise KeyError: if the tag key is already registered and ``force`` is
                 not true.
             """
             tag = tag_class(self)
             key = tag.key

             if key is not None:
                 if not force and key in self.tags:
                     raise KeyError("Tag '{0}' is already registered.".format(key))

                 self.tags[key] = tag

             if index is None:
                 self.order.append(tag)
             else:
                 self.order.insert(index, tag)

         def tag(self, value):
             """Convert a value to a tagged representation if necessary."""
             for tag in self.order:
                 if tag.check(value):
                     return tag.tag(value)

             return value

         def untag(self, value):
             """Convert a tagged representation back to the original type."""
             if len(value) != 1:
                 return value

             key = next(iter(value))

             if key not in self.tags:
                 return value

             return self.tags[key].to_python(value[key])

         def dumps(self, value):
             """Tag the value and dump it to a compact JSON string."""
             return dumps(self.tag(value), separators=(',', ':'))

         def loads(self, value):
             """Load data from a JSON string and deserialized any tagged objects."""
             return loads(value, object_hook=self.untag)
   #+END_SRC

   这个， 嗯， 抽象工厂模式 ？

   这个模块很容易扩展， 基于这两个类， 后序的扩展只需要继承 ~JSONTag~ 并实现相应的接口， 然后
   在使用时通过 ~TaggedJSONSerializer.register~ 注册即可。

   其他对 ~JSONTag~ 的继承实现可以不忙看， 搞清楚这两个类基本就搞清楚这个模块了。

   首先， 实例化 ~TaggedJSONSerializer~ 对象的时候， 这个实例会自动添加 ~tags~ 和 ~order~ 这两个属性。

   并调用 ~register~ 方法注册默认的 ~JSONTag~ 实现。

   ~register~ 的流程为：
   1. 实例化注册的 ~JSONTag~ 实现， 这里就可以明白， ~JSONTag~ 的 ~serializer~ 属性的来源了。
   2. 获取注册的 ~JSONTag~ 实现的 ~key~ 属性
   3. 如果 ~key~ 存在了标签 ~force~ 参数为 ~None~, 就抛出异常。 如果 ~force~ 参数不为 ~None~, 
      便将原有的 ~JSONTag~ 实现覆盖。
   4. 如果 ~index~ 为空， 则这个 ~JSONTag~ 实现添加到 ~order~ 列表末尾。 否则添加到指定 ~index~ 处

   这里可以看到， 注册的 ~JSONTag~ 实现的实例同时保存在 ~tags~ 和 ~order~ 中， ~tags~ 是映射关系， 而
   ~order~ 是顺序关系。

   方法 ~tag~ 调用 ~JSONTag~ 对象的 ~check~ 方法检查该对象是否为需要被标记的对象， 这个顺序按照 ~order~ 进行。

   如果是， 则使用 ~tag.tag~ 标记为 ~{self.key: self.to_json(value)}~.

   而 ~untag~ 方法则根据标记后的 ~key~ 将其转换为原有对象。

   ~next(iter(value))~ 取长度为 1 的序列的元素的操作也很骚。

   这两个方法的配合感觉很精彩， 真滴很 nice !!!

   ~dumps~ 和 ~loads~ 就配合这两个方法使用， 嗯， 很好， 很好 ！！！

   这应该是我目前看过的源码中， 最精彩的操作之一了 (｀・ω・´)
