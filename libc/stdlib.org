#+TITLE:      stdlib
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#stdlib][stdlib]]
- [[#abs][abs]]
- [[#div][div]]
- [[#labs--ldiv][labs & ldiv]]
- [[#qsort][qsort]]
- [[#bsearch][bsearch]]
- [[#rand--srand][rand & srand]]
- [[#_stoul][_Stoul]]
- [[#_stod][_Stod]]
- [[#å‰åŠéƒ¨åˆ†æ±‡æ€»][å‰åŠéƒ¨åˆ†æ±‡æ€»]]
- [[#å¤šå­—èŠ‚å­—ç¬¦å‡½æ•°][å¤šå­—èŠ‚å­—ç¬¦å‡½æ•°]]
- [[#å†…å­˜ç®¡ç†å‡½æ•°][å†…å­˜ç®¡ç†å‡½æ•°]]

* stdlib
  ~stdlib.h~ æ˜¯æˆ‘ç›®å‰ä½¿ç”¨é¢‘ç‡æœ€å¤šçš„å¤´æ–‡ä»¶ä¹‹ä¸€ï¼Œ åŒ…å«äº†å¾ˆå¤šæœ‰ç”¨çš„å†…å®¹ã€‚

  åœ¨ [[https://book.douban.com/subject/3775842/][C æ ‡å‡†åº“]] è¿™æœ¬ä¹¦ä¸Šå°†è¿™ä¸ªå¤´æ–‡ä»¶åŒ…å«çš„å‡½æ•°åˆ†ä¸ºäº† ~6~ ç»„ï¼š
  + æ•´å‹æ•°å­¦(absã€ divã€ labs å’Œ ldiv) -- æ‰§è¡Œç®€å•çš„æ•´å‹ç®—æ•°
  + ç®—æ³•(bsearchã€ qsortã€ rand å’Œ srand) -- æ”¶é›†é‚£äº›å¤æ‚è€Œåˆè¢«å¹¿æ³›ä½¿ç”¨çš„ã€ è¶³ä»¥æ‰“åŒ…ä¸ºåº“å‡½æ•°çš„æ“ä½œ
  + æ–‡æœ¬è½¬æ¢(atofã€ atoiã€ atolã€ strtodã€ strtol å’Œ strtoul) -- ç¡®å®šæ–‡æœ¬è¡¨ç¤ºçš„ç¼–ç ç®—æœ¯å€¼
  + å¤šå­—èŠ‚è½¬æ¢(mblenã€ mbstowcsã€ mbtowcã€ wcstombs å’Œ wctomb) -- å¤šå­—èŠ‚å’Œå®½å­—ç¬¦å­—ç¬¦ç¼–ç ä¹‹é—´çš„è½¬æ¢
  + å­˜å‚¨åˆ†é…(callocã€ freeã€ malloc å’Œ realloc) -- ç®¡ç†æ•°æ®å¯¹è±¡çš„å †
  + ç¯å¢ƒæ¥å£(abortã€ atexitã€ exitã€ getenv å’Œ system) -- ç¨‹åºå’Œæ‰§è¡Œç¯å¢ƒä¹‹é—´çš„æ¥å£

  ä¹¦ä¸­ ~<stdlib.h>~ çš„éƒ¨åˆ†å†…å®¹ï¼š
  #+BEGIN_SRC C
    #define EXIT_SUCCESS 0

    typedef struct {
      int quot;
      int rem;
    } div_t;

    typedef struct {
      long quot;
      long rem;
    } ldiv_t;

    typedef struct {
      unsigned char _State;
      unsigned short _Wchar;
    } _Mbsave;

    typedef int _Cmpfun(const void *, const void *);
  #+END_SRC

* abs
  å‡½æ•° ~abs~ è®¡ç®—æ•´æ•°çš„ç»å¯¹å€¼ï¼š
  #+BEGIN_SRC C
    #include <stdlib.h>

    int abs(int n) {
      return n < 0 ? -n : n;
    }
  #+END_SRC

  è´´çš„ä»£ç æ²¡æœ‰å®Œå…¨å‚è€ƒä¹¦ä¸Šçš„ï¼Œ è€Œæ˜¯æŒ‰ç…§è‡ªå·±ä¹ æƒ¯çš„æ–¹å¼è¿›è¡Œäº†æ”¹åŠ¨ï¼Œ åæ­£ä¸å½±å“ç†è§£å³å¯ã€‚

* div
  å‡½æ•° ~div~ è®¡ç®—åˆ†å­ ~number~ é™¤ä»¥åˆ†æ¯ ~denom~ æ‰€å¾—çš„å•†å’Œä½™æ•°ï¼š
  #+BEGIN_SRC C
    #include <stdlib.h>

    div_t div(int number, int denom) {
      div_t val;

      val.quot = number / denom;
      val.rem = number - denom * val.quot;

      if (val.quot < 0 && 0 < val.rem) {
        val.quot += 1;
        val.rem -= denom;
      }

      return val;
    }
  #+END_SRC

  ä¸­é—´çš„ ~if~ æ˜¯å¤„ç†ä½™æ•°ç¬¦å·é”™è¯¯çš„é—®é¢˜çš„ï¼Œ æ²¡æœ‰è¿™ä¸€æ®µçš„è¯ï¼Œ ~div(-10, 3)~ çš„ç»“æœä¼šæ˜¯ï¼š ~[-4, 2]~.

  ~-10 / 3~ çš„ç»“æœæ˜¯ ~-3.3~, å‘ä¸‹å–æ•´å°±æˆäº† ~-4~, è€Œä½™æ•°å°±æˆäº† ~2~.

  é€šè¿‡ ~if~ è¿™ä¸€æ®µçš„å¤„ç†ï¼Œ è´Ÿæ•°éƒ¨åˆ† *å‘ä¸Šå–æ•´*, å¾—åˆ°çš„ç»“æœå°±æ˜¯ ~[-3, -1]~.
  
* labs & ldiv
  é“ç†å’Œ ~abs~ ä¸ ~div~ ä¸€æ ·ï¼š
  #+BEGIN_SRC C
    #include <stdlib.h>

    long abs(long n) {
      return n < 0 ? -n : n;
    }

    ldiv_t ldiv(long number, long denom) {
      ldiv_t val;

      val.quot = number / denom;
      val.rem = number - denom * val.quot;

      if (val.quot < 0 && 0 < val.rem) {
        val.quot += 1;
        val.rem -= denom;
      }

      return val;
    }
  #+END_SRC

* qsort
  è¿™ä¸ªå‡½æ•°ç”¨äºå¯¹ä»»æ„ä¸€ä¸ªæ•°ç»„è¿›è¡Œæ’åºï¼Œ å†…éƒ¨å®ç°çš„ç®—æ³•ä¸ç¡®å®šï¼Œ ç”±å„ä¸ªå®ç°å…·ä½“å‘æŒ¥ã€‚

  ä½†è‚¯å®šæ¯”è‡ªå·±å†™çš„å¥½......

  #+BEGIN_SRC C
    #include <stdlib.h>
    #include <string.h>

    #define MAX_BUF 256

    void qsort(void* base, size_t n, size_t size, _Cmpfun* cmp) {
      while (1 < n) {
        size_t i = 0;
        size_t j = n - 1;
        char* qi = (char*)base;
        char* qj = qi + size * j;
        char* qp = qj;

        while (i < j) {
          while (i < j && (*cmp)(qi, qp) <= 0) {
            qi += size;
            ++i;
          }

          while (i < j && (*cmp)(qp, qj) <= 0) {
            qj -= size;
            --j;
          }

          if (i < j) {
            char buf[MAX_BUF];
            char* q1 = qi;
            char* q2 = qj;
            size_t m, ms;  // element, element size

            for (ms = size; 0 < ms; ms -= m, q1 += m, q2 -= m) {
              m = ms < sizeof(buf) ? ms : sizeof(buf);
              memcpy(buf, q1, m);
              memcpy(q1, q2, m);
              memcpy(q2, buf, m);
            }

            qi += size;
            ++i;
          }
        }

        if (qi != qp) {
          char buf[MAX_BUF];
          char* q1 = qi;
          char* q2 = qp;
          size_t m, ms;

          for (ms = size; 0 < ms; ms -= m, q1 += m, q2 -= m) {
            m = ms < sizeof(buf) ? ms : sizeof(buf);
            memcpy(buf, q1, m);
            memcpy(q1, q2, m);
            memcpy(q2, buf, m);
          }
        }

        j = n - i - 1;
        qi += size;

        if (j < i) {
          if (1 < j) {
            qsort(qi, j, size, cmp);
          }
          n = i;
        } else {
          if (1 < i) {
            qsort(base, i, size, cmp);
          }
          base = qi;
          n = j;
        }
      }
    }
  #+END_SRC

  emmmm...

  ~qsort~ çš„å‡ ä¸ªå‚æ•°åˆ†åˆ«ä¸ºï¼š
  + base: è¦æ’åºçš„æ•°ç»„
  + n: æ•°ç»„å…ƒç´ çš„ä¸ªæ•°
  + size: æ•°ç»„å…ƒç´ çš„å¤§å°
  + cmp: æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„å…ƒç´ å¤§å°çš„å‡½æ•°

  æ ¹æ® ~cmp~ çš„è¿”å›å€¼å¯¹æ•°ç»„è¿›è¡Œ *å‡åº* æ’åºï¼Œ å¦‚æœç¬¬ä¸€ä¸ªå‚æ•°å°äºã€ ç­‰äºæˆ–å¤§äºç¬¬äºŒä¸ªå…ƒç´ ï¼Œ åˆ™å‡½æ•°
  åˆ†åˆ«è¿”å›å°äºé›¶ã€ ç­‰äºé›¶å’Œå¤§äºé›¶çš„æ•´æ•°ã€‚

  ç®€å•æ¥è¯´ï¼Œ è¦ *å‡åº* å°±æ˜¯ *ç¬¬ä¸€ä¸ªå…ƒç´ * - *ç¬¬äºŒä¸ªå…ƒç´ *.

  è¦ *é™åº* å°±æ˜¯ *ç¬¬äºŒä¸ªå…ƒç´ * - *ç¬¬ä¸€ä¸ªå…ƒç´ *.

  å‡½æ•°å®ç°ä½¿ç”¨äº† ~memcpy~ å†…å­˜æ‹·è´å‡½æ•°ï¼Œ åŠŸèƒ½æ˜¯ä»æºå†…å­˜åœ°å€çš„èµ·å§‹ä½ç½®å¼€å§‹æ‹·è´ ~n~ ä¸ªå­—èŠ‚åˆ°ç›®æ ‡å†…å­˜åœ°å€çš„èµ·å§‹ä½ç½®ä¸­ã€‚

  å†…éƒ¨éƒ½æ˜¯ç›´æ¥æ“ä½œçš„å­—èŠ‚äº†ï¼Œ æ’åºçš„ä¸»è¦ä¾æ®å°±çœ‹æä¾›çš„ ~cmp~.

* bsearch
  è¿™ä¸ªåº”è¯¥æ¯” ~qsort~ ç®€å•å§......

  æŸ¥æ‰¾æŒ‡å®šå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®ï¼š
  #+BEGIN_SRC C
    #include <stdlib.h>

    void* bsearch(const void* key, const void* base, size_t nelem,
                  size_t size, _Cmpfun cmp) {
      const char* p;
      size_t n;

      for (p = (const char*)base, n = nelem; 0 < n;) {
        const size_t pivot = n >> 1;
        const char* const q = p + size * pivot;
        const int val = (*cmp)(key, q);

        if (val < 0) {
          n = pivot;
        } else if (val == 0) {
          return (void*)q;
        } else {
          p = q + size;
          n -= pivot + 1;
        }
      }

      return NULL;
    }
  #+END_SRC

  éœ€è¦äº†è§£ä¸€ä¸‹ ~const~ æŒ‡é’ˆï¼š [[http://www.cnblogs.com/younes/archive/2009/12/02/1615348.html][const æŒ‡é’ˆä¸æŒ‡å‘constçš„æŒ‡é’ˆ]]
  
  è¿™é‡Œéœ€è¦ä½ çš„æ•°ç»„æ˜¯æ’å¥½åºçš„ï¼Œ å¯ä»¥ç»“åˆ ~qsort~ ä½¿ç”¨ã€‚

* rand & srand
  è¿™ä¸¤ä¸ªå‡½æ•°ä½¿ç”¨çš„åº”è¯¥æ¯”è¾ƒå¤šï¼Œ ç”¨äºç”Ÿæˆéšæœºæ•°ï¼š
  #+BEGIN_SRC C
    #include <stdlib.h>

    unsigned long _Randseed = 1;

    int rand(void) {
      _Randseed = _Randseed * 1103515245 + 12345;
      return ((unsigned int)(_Randseed >> 16) & RADN_MAX);
    }

    void srand(unsigned int seed) {
      _Randseed = seed;
    }
  #+END_SRC

  å¦‚æœéœ€è¦ ~[0, 1]~ ä¹‹é—´çš„éšæœºæ•°ï¼Œ å¯ä»¥ä½¿ç”¨ï¼š ~(float)rand() / RADN_MAX~.

  ~rand()~ äº§ç”Ÿçš„å€¼åœ¨ ~[0, RADN_MAX]~ ä¹‹é—´ï¼Œ è€Œ ~RADN_MAX~ è¦æ±‚çš„æœ€å°å€¼ä¸º 32767.

  ç„äº†ä¸€çœ¼ ~glibc~ ä¸­çš„ [[http://repo.or.cz/glibc.git/tree/HEAD:/stdlib][å®ç°]], å•§ï¼Œ è¿˜æ˜¯çœ‹ä¹¦å¥½ (ï¿£â–½ï¿£)ï¼

* _Stoul
  è¿™ä¸ªå‡½æ•°åœ¨ä¹¦ä¸­ç”¨äºå®ç° ~atoi~, ~atol~, ~strtoul~, ~strtol~ è¿™å‡ ä¸ªå‡½æ•°ã€‚
  
  #+BEGIN_SRC C
    #include <stdlib.h>
    #include <ctype.h>
    #include <errno.h>
    #include <limits.h>
    #include <stddef.h>
    #include <string.h>

    #define BASE_MAX 36

    static const char digits[] = {"0123456789abcdefghijklmnopqrstuvwxyz"};
    static const char ndigs[BASE_MAX + 1] = {
      0, 0, 33, 21, 17, 13, 12, 11, 11,
      10, 10, 9, 9, 9, 9, 9, 8, 8, 8,
      8, 8, 8, 8, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7
    };

    unsigned long _Stoul(const char* s, char** endptr, int base) {
      const char* sc;
      const char* sd;
      const char* s1;
      const char* s2;
      char sign;
      ptrdiff_t n;  // stddef.h
      unsigned long x, y;

      for (sc = s; isspace(*sc); ++sc);  // è·³è¿‡å‰é¢çš„ç©ºç™½å­—ç¬¦

      sign = *sc == '-' || *sc == '+' ? *sc++ : '+';  // åˆ¤æ–­ç¬¦å·

      if (base < 0 || base == 1 || BASE_MAX < base) {  // åˆ¤æ–­è¿›åˆ¶
        if (endptr) {
          *endptr = (char*)s;
        }
        return 0;
      } else if (base) {
        if (base == 16 && *sc == '0' && (sc[1] == 'x' || sc[1] == 'X')) {
          sc += 2;
        }
      } else if (*sc != 0) {
        base = 10;
      } else if (sc[1] == 'x' || sc[1] == 'X') {
        base = 16, sc += 2;
      } else {
        base = 8;
      }

      for (s1 = sc; *sc == '0'; ++sc);  // è·³è¿‡å‰å¯¼ 0

      x = 0;
      for (s2 = sc; (sd = memchr(digits, tolower(*sc), base)) != NULL; ++sc) {  // http://www.runoob.com/cprogramming/c-function-memchr.html
        y = x;
        x = x * base + (sd - digits);  // sd - digits ç­‰äº sd åœ¨ digits çš„ç´¢å¼•
      }

      if (s1 == sc) {
        if (endptr) {
          *endptr = (char*)s;
        }
        return 0;
      }

      n = sc - s2 - ndigs[base];
      if (n < 0) {
        ;
      } else if (0 < n || x < x - sc[-1] || (x - sc[-1]) / base != y) {
        errno = ERANGE;
        x = ULONG_MAX;
      }

      if (sign == '-') {
        x = -x;
      }

      if (endptr) {
        *endptr = (char*)sc;
      }

      return x;
    }
  #+END_SRC

  ~_Stoul~ çš„ä½œç”¨æ˜¯å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ— ç¬¦å·é•¿æ•´æ•°ã€‚

  ç”¨æƒ¯äº† ~Python~ è¿™ç±»é«˜çº§è¯­è¨€ï¼Œ è¿™é‡Œçœ‹ ~C~ æœç„¶ä¸ä¹ æƒ¯ã€‚

  æ„Ÿè§‰è¿™äº›æ“ä½œå°±æ˜¯åœ¨å†…å­˜ä¸Šç›´æ¥æ“åˆ€ï¼Œ ä¸æƒ³å…¶ä»–è¯­è¨€å°†è¿™äº›æ•°æ®æŠ½è±¡ä¸ºäº†ä¸€ä¸ªä¸ªå¯¹è±¡ï¼Œ è€Œæ˜¯
  ç›´æ¥æ“ä½œè¿™äº›æ•°æ®æœ¬èº«ã€‚

  æ„Ÿè§‰èƒ½åŠ›ä¸Šæ›´åŠ å¼ºå¤§ï¼Œ ä½†å¯èƒ½çš„é£é™©ä¹Ÿç¡®å®å¤šä¸€äº›......
  
  æ„Ÿè§‰æ–°å¥‡çš„æ“ä½œï¼š
  + ç±»ä¼¼ ~memchr~ çš„å‡½æ•°è¿”å›å€¼æ˜¯æŒ‡å‘ç›®æ ‡çš„æŒ‡é’ˆï¼Œ ä½¿ç”¨è¿™ä¸ªè¿”å›å€¼å‡å»æ•°ç»„çš„åŸºå€ï¼Œ å°±è·å¾—
    äº†è¯¥ç›®æ ‡åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•
  + ~sc[-1]~ ç­‰ä»·äº ~*(sc - 1)~, æ²¡æœ‰æŠŠæ¡è¿˜æ˜¯ä¸è¦ç”¨çš„å¥½

  å‰©ä¸‹å‡ ä¸ªå‡½æ•°çš„å®ç°ï¼š
  #+BEGIN_SRC C
    #include <ctype.h>
    #include <errno.h>
    #include <limits.h>
    #include <stdlib.h>


    int atoi(const char* s) {
      return (int)_Stoul(s, NULL, 10);
    }

    long atol(const char* s) {
      return (long)_Stoul(s, NULL, 10);
    }

    unsigned long strtoul(const char* s, char** endptr, int base) {
      return _Stoul(s, endptr, base);
    }

    long strtol(const char*s, char** endptr, int base) {
      const char* sc;
      unsigned long x;

      for (sc = s; isspace(*sc); ++sc);

      x = _Stoul(s, endptr, base);
      if (*sc == '-' && x < LONG_MAX) {
        errno = ERANGE;
        return LONG_MIN;
      } else if (*sc != '-' && LONG_MAX < x) {
        errno = ERANGE;
        return LONG_MAX;
      } else {
        return (long)x;
      }
    }
  #+END_SRC

* _Stod
  ~_Stod~ æ˜¯ç”¨æ¥å®ç° ~atof~ å’Œ ~strtod~ è¿™ä¸¤ä¸ªå‡½æ•°çš„ã€‚

  åˆ†åˆ«å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º ~float~ å’Œ ~double~ ç±»å‹çš„å€¼ã€‚

* å‰åŠéƒ¨åˆ†æ±‡æ€»
  çœ‹äº†è¿™éƒ¨åˆ† *C æ ‡å‡†åº“* å‡½æ•°çš„ä½œç”¨å’Œå®ç°ä»£ç åï¼Œ å‘ç°ï¼Œ æœç„¶è¿˜æ˜¯å¯¹å®ƒä»¬çš„ä½œç”¨å’Œä½¿ç”¨æ›´æ„Ÿå…´è¶£ã€‚

  è€Œæ›´å¤šå‡½æ•°çš„å®ç°çœ‹èµ·æ¥éƒ½å¾ˆæ¯ç‡¥ï¼Œ å½“ç„¶ä¹Ÿæœ‰éƒ¨åˆ†ä¾‹å¤–ã€‚

  æ¯ç‡¥çš„æºç é˜…è¯»èµ·æ¥æ”¶è·å°‘è¿˜æµªè´¹æ—¶é—´ï¼Œ æ‰€ä»¥ï¼Œ åé¢çš„æºç æ‰¾æ„Ÿå…´è¶£çš„æµè§ˆä¸€ä¸‹ï¼Œ ä¸æ„Ÿå…´è¶£çš„ç›´æ¥ç•¥è¿‡ã€‚

  é¡ºä¾¿æ±‡æ€»ä¸€ä¸‹å‰é¢è¿™äº›å‡½æ•°çš„åŸå‹ï¼š
  #+BEGIN_SRC C
    // æ±‚ç»å¯¹å€¼
    int abs(int num);
    long labs(long num);

    // åŒæ—¶è®¡ç®—å•†å’Œä½™æ•°
    div_t div(int number, int denom);
    ldiv_t ldiv(long number, long denom);

    // æ’åºå’ŒæŸ¥æ‰¾
    void qsort(void* base, size_t count, size_t size,
               int (*comp)(const void *, const void *));
    void* bsearch(const void *key, const void *base, size_t count, size_t size,
                   int (*comp)(const void*, const void*));

    // éšæœºæ•°
    int rand(void);
    void srand(unsigned int seed);

    // å­—ç¬¦ä¸²è½¬æ•´æ•°
    int atoi(const char* s);
    long atol(count char* s);
    long strtol(count char* s, char** endptr, int base);
    unsigned long strtoul(const char* s, char** endptr, int base);

    // å­—ç¬¦ä¸²è½¬æµ®ç‚¹æ•°
    double atof(const char* s);
    double strtod(const char* s, char** endptr);
  #+END_SRC

* å¤šå­—èŠ‚å­—ç¬¦å‡½æ•°
  è¿™ä¸€éƒ¨åˆ†çš„å‡½æ•°çœ‹çš„æœ‰ç‚¹æ‡µé€¼ï¼Œ è™½ç„¶ä¹‹å‰äº†è§£è¿‡å®½å­—ç¬¦å’Œå¤šå­—èŠ‚å­—ç¬¦çš„æ¦‚å¿µï¼Œ ä½†æ˜¯å½“æ—¶çš„ç†è§£
  ä¼¼ä¹ä¸æ˜¯å¾ˆé€å½»ï¼Œ ç°åœ¨è¿™éƒ¨åˆ†å‡½æ•°çš„ä½¿ç”¨ç†è§£èµ·æ¥éƒ½æœ‰äº›å›°éš¾ï¼Œ ä¸è¯´ç†è§£æºç äº†......

  + int mblen(const char* s, size_t n) :: ç¡®å®š ~s~ æŒ‡å‘çš„çš„å¤šå­—èŠ‚ *å­—ç¬¦* çš„ *å­—èŠ‚æ•°*, å¦‚æœ ~s~ æŒ‡å‘çš„æ˜¯ä¸€ä¸ª
       å¤šå­—èŠ‚ *å­—ç¬¦ä¸²*, é‚£ä¹ˆ ~mblen~ ä¹Ÿåªä¼šè¿”å›å¤´ä¸€ä¸ªå¤šå­—èŠ‚å­—ç¬¦çš„å­—èŠ‚æ•°ï¼Œ å‰©ä¸‹çš„å­—ç¬¦ä¸²ä¸åšè®¡ç®—ã€‚

       ç¡®å®šä¸€ä¸ªå¤šå­—èŠ‚å­—ç¬¦ä¸²çš„é•¿åº¦å¯ä»¥åƒè¿™æ ·ï¼š
       #+BEGIN_SRC C
         #include <string.h>
         #include <stdlib.h>
         #include <locale.h>
         #include <stdio.h>

         // the number of characters in a multibyte string is the sum of mblen()'s
         // note: the simpler approach is mbstowcs(NULL, str, sz)
         size_t strlen_mb(const char* ptr) {
           size_t result = 0;
           const char* end = ptr + strlen(ptr);
           mblen(NULL, 0); // reset the conversion state
           while(ptr < end) {
             int next = mblen(ptr, end - ptr);  // multibyte character size
             if(next == -1) {
               perror("strlen_mb");
               break;
             }
             ptr += next;
             ++result;
           }
           return result;
         }

         int main(void) {
           setlocale(LC_ALL, "en_US.utf8");
           const char* str = "z\u00df\u6c34\U0001f34c";
           printf("The string %s consists of %zu bytes, but only %zu characters\n",
                  str, strlen(str), strlen_mb(str));
         }
       #+END_SRC

       å¯èƒ½çš„è¾“å‡ºï¼š
       #+BEGIN_EXAMPLE
         The string zÃŸæ°´ğŸŒ consists of 10 bytes, but only 4 characters
       #+END_EXAMPLE

       åˆ¤æ–­å½“å‰å¤šå­—èŠ‚å­—ç¬¦æ˜¯å¦ç»“æŸåº”è¯¥å’Œå­—ç¬¦ç¼–ç çš„å†…å®¹ç›¸å…³......

  + int mbtowc(wchar_t* pwc, const char* s, size_t n) :: å°†ä¸‹ä¸€ä¸ªå¤šå­—èŠ‚å­—ç¬¦è½¬æ¢æˆå®½å­—ç¬¦

  + size_t mbstowcs(wchar_t* wcs, const char* s, size_t n) :: å°†å¤šå­—èŠ‚å­—ç¬¦ä¸²è½¬æ¢æˆå®½å­—ç¬¦ä¸²

  + int wctomb(char* s, wchar wchar) :: å°†å®½å­—ç¬¦è½¬æ¢æˆå…¶å¤šå­—èŠ‚è¡¨ç¤º

  + size_t wcstombs(char* s, const wchar_t* wcs, size_t n) :: å°†å®½å­—ç¬¦ä¸²è½¬æ¢æˆå¤šå­—èŠ‚å­—ç¬¦ä¸² 

  æ„Ÿè§‰è¿™éƒ¨åˆ†çš„ä»£ç åº”è¯¥æŠ›å¼€å­—ç¬¦ç¼–ç è¿›è¡Œç†è§£ï¼Œ å¦‚æœä¸è€ƒè™‘ç¼–ç çš„è¯ï¼Œ è¿™äº›å‡½æ•°çš„ä½œç”¨å°±æ˜¯å°† *å•å­—èŠ‚* æ•°æ®
  å’Œ *å¤šå­—èŠ‚* æ•°æ®ä¹‹é—´è½¬æ¢ï¼Œ å¦‚ ~char~ å’Œ ~int~.

  ç¼–ç å½±å“è¿™ä¸ªè½¬æ¢è§„åˆ™ã€‚

* å†…å­˜ç®¡ç†å‡½æ•°
  è¿™åº”è¯¥æ˜¯ç›¸å½“ç†Ÿæ‚‰çš„å‡ ä¸ªå‡½æ•°äº†ï¼š
  #+BEGIN_SRC C
    void* malloc(size_t size);
    void* calloc(size_t nmemb, size_t size);
    void* realloc(void* ptr, size_t size);
    void free(void* ptr);
  #+END_SRC

  åœ¨ä¹‹å‰çš„æ“ä½œç³»ç»Ÿä½¿å®éªŒä¸­å·²ç»äº†è§£è¿‡å†…å­˜ç®¡ç†å‡½æ•°çš„å®ç°äº†ï¼Œ å‘ç°è¿™ä¸ªå®ç°å’Œæˆ‘æƒ³è±¡çš„åŒºåˆ«æœ‰ç‚¹å¤§......

  å‡½æ•°ä½¿ç”¨ï¼š
  + ~malloc~ ç”³è¯·æŒ‡å®šå¤§å°çš„å†…å­˜ç©ºé—´ï¼Œ ä¸åˆå§‹åŒ–
  + ~calloc~ ç”³è¯· ~nmemb * size~ å¤§å°çš„å†…å­˜ç©ºé—´ï¼Œ åˆå§‹åŒ–ä¸º 0
  + ~realloc~ å°† ~ptr~ æŒ‡å‘çš„å¯¹è±¡çš„å¤§å°æ”¹å˜ä¸ºç”± ~size~ æŒ‡å®šçš„å¤§å°ã€‚ä¸åˆå§‹åŒ–ã€‚ å’Œå®ç°ç›¸å…³ï¼Œ è¿”å›çš„åœ°å€å¯èƒ½å’Œ ~ptr~ åŸåœ°å€ä¸åŒã€‚
  + ~free~ é‡Šæ”¾å†…å­˜

