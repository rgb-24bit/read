#+TITLE:      stdlib
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#stdlib][stdlib]]
- [[#abs][abs]]
- [[#div][div]]
- [[#labs--ldiv][labs & ldiv]]
- [[#qsort][qsort]]
- [[#bsearch][bsearch]]
- [[#rand--srand][rand & srand]]
- [[#_stoul][_Stoul]]
- [[#_stod][_Stod]]
- [[#前半部分汇总][前半部分汇总]]
- [[#多字节字符函数][多字节字符函数]]
- [[#内存管理函数][内存管理函数]]

* stdlib
  ~stdlib.h~ 是我目前使用频率最多的头文件之一， 包含了很多有用的内容。

  在 [[https://book.douban.com/subject/3775842/][C 标准库]] 这本书上将这个头文件包含的函数分为了 ~6~ 组：
  + 整型数学(abs、 div、 labs 和 ldiv) -- 执行简单的整型算数
  + 算法(bsearch、 qsort、 rand 和 srand) -- 收集那些复杂而又被广泛使用的、 足以打包为库函数的操作
  + 文本转换(atof、 atoi、 atol、 strtod、 strtol 和 strtoul) -- 确定文本表示的编码算术值
  + 多字节转换(mblen、 mbstowcs、 mbtowc、 wcstombs 和 wctomb) -- 多字节和宽字符字符编码之间的转换
  + 存储分配(calloc、 free、 malloc 和 realloc) -- 管理数据对象的堆
  + 环境接口(abort、 atexit、 exit、 getenv 和 system) -- 程序和执行环境之间的接口

  书中 ~<stdlib.h>~ 的部分内容：
  #+BEGIN_SRC C
    #define EXIT_SUCCESS 0

    typedef struct {
      int quot;
      int rem;
    } div_t;

    typedef struct {
      long quot;
      long rem;
    } ldiv_t;

    typedef struct {
      unsigned char _State;
      unsigned short _Wchar;
    } _Mbsave;

    typedef int _Cmpfun(const void *, const void *);
  #+END_SRC

* abs
  函数 ~abs~ 计算整数的绝对值：
  #+BEGIN_SRC C
    #include <stdlib.h>

    int abs(int n) {
      return n < 0 ? -n : n;
    }
  #+END_SRC

  贴的代码没有完全参考书上的， 而是按照自己习惯的方式进行了改动， 反正不影响理解即可。

* div
  函数 ~div~ 计算分子 ~number~ 除以分母 ~denom~ 所得的商和余数：
  #+BEGIN_SRC C
    #include <stdlib.h>

    div_t div(int number, int denom) {
      div_t val;

      val.quot = number / denom;
      val.rem = number - denom * val.quot;

      if (val.quot < 0 && 0 < val.rem) {
        val.quot += 1;
        val.rem -= denom;
      }

      return val;
    }
  #+END_SRC

  中间的 ~if~ 是处理余数符号错误的问题的， 没有这一段的话， ~div(-10, 3)~ 的结果会是： ~[-4, 2]~.

  ~-10 / 3~ 的结果是 ~-3.3~, 向下取整就成了 ~-4~, 而余数就成了 ~2~.

  通过 ~if~ 这一段的处理， 负数部分 *向上取整*, 得到的结果就是 ~[-3, -1]~.
  
* labs & ldiv
  道理和 ~abs~ 与 ~div~ 一样：
  #+BEGIN_SRC C
    #include <stdlib.h>

    long abs(long n) {
      return n < 0 ? -n : n;
    }

    ldiv_t ldiv(long number, long denom) {
      ldiv_t val;

      val.quot = number / denom;
      val.rem = number - denom * val.quot;

      if (val.quot < 0 && 0 < val.rem) {
        val.quot += 1;
        val.rem -= denom;
      }

      return val;
    }
  #+END_SRC

* qsort
  这个函数用于对任意一个数组进行排序， 内部实现的算法不确定， 由各个实现具体发挥。

  但肯定比自己写的好......

  #+BEGIN_SRC C
    #include <stdlib.h>
    #include <string.h>

    #define MAX_BUF 256

    void qsort(void* base, size_t n, size_t size, _Cmpfun* cmp) {
      while (1 < n) {
        size_t i = 0;
        size_t j = n - 1;
        char* qi = (char*)base;
        char* qj = qi + size * j;
        char* qp = qj;

        while (i < j) {
          while (i < j && (*cmp)(qi, qp) <= 0) {
            qi += size;
            ++i;
          }

          while (i < j && (*cmp)(qp, qj) <= 0) {
            qj -= size;
            --j;
          }

          if (i < j) {
            char buf[MAX_BUF];
            char* q1 = qi;
            char* q2 = qj;
            size_t m, ms;  // element, element size

            for (ms = size; 0 < ms; ms -= m, q1 += m, q2 -= m) {
              m = ms < sizeof(buf) ? ms : sizeof(buf);
              memcpy(buf, q1, m);
              memcpy(q1, q2, m);
              memcpy(q2, buf, m);
            }

            qi += size;
            ++i;
          }
        }

        if (qi != qp) {
          char buf[MAX_BUF];
          char* q1 = qi;
          char* q2 = qp;
          size_t m, ms;

          for (ms = size; 0 < ms; ms -= m, q1 += m, q2 -= m) {
            m = ms < sizeof(buf) ? ms : sizeof(buf);
            memcpy(buf, q1, m);
            memcpy(q1, q2, m);
            memcpy(q2, buf, m);
          }
        }

        j = n - i - 1;
        qi += size;

        if (j < i) {
          if (1 < j) {
            qsort(qi, j, size, cmp);
          }
          n = i;
        } else {
          if (1 < i) {
            qsort(base, i, size, cmp);
          }
          base = qi;
          n = j;
        }
      }
    }
  #+END_SRC

  emmmm...

  ~qsort~ 的几个参数分别为：
  + base: 要排序的数组
  + n: 数组元素的个数
  + size: 数组元素的大小
  + cmp: 比较两个数组元素大小的函数

  根据 ~cmp~ 的返回值对数组进行 *升序* 排序， 如果第一个参数小于、 等于或大于第二个元素， 则函数
  分别返回小于零、 等于零和大于零的整数。

  简单来说， 要 *升序* 就是 *第一个元素* - *第二个元素*.

  要 *降序* 就是 *第二个元素* - *第一个元素*.

  函数实现使用了 ~memcpy~ 内存拷贝函数， 功能是从源内存地址的起始位置开始拷贝 ~n~ 个字节到目标内存地址的起始位置中。

  内部都是直接操作的字节了， 排序的主要依据就看提供的 ~cmp~.

* bsearch
  这个应该比 ~qsort~ 简单吧......

  查找指定元素在数组中的位置：
  #+BEGIN_SRC C
    #include <stdlib.h>

    void* bsearch(const void* key, const void* base, size_t nelem,
                  size_t size, _Cmpfun cmp) {
      const char* p;
      size_t n;

      for (p = (const char*)base, n = nelem; 0 < n;) {
        const size_t pivot = n >> 1;
        const char* const q = p + size * pivot;
        const int val = (*cmp)(key, q);

        if (val < 0) {
          n = pivot;
        } else if (val == 0) {
          return (void*)q;
        } else {
          p = q + size;
          n -= pivot + 1;
        }
      }

      return NULL;
    }
  #+END_SRC

  需要了解一下 ~const~ 指针： [[http://www.cnblogs.com/younes/archive/2009/12/02/1615348.html][const 指针与指向const的指针]]
  
  这里需要你的数组是排好序的， 可以结合 ~qsort~ 使用。

* rand & srand
  这两个函数使用的应该比较多， 用于生成随机数：
  #+BEGIN_SRC C
    #include <stdlib.h>

    unsigned long _Randseed = 1;

    int rand(void) {
      _Randseed = _Randseed * 1103515245 + 12345;
      return ((unsigned int)(_Randseed >> 16) & RADN_MAX);
    }

    void srand(unsigned int seed) {
      _Randseed = seed;
    }
  #+END_SRC

  如果需要 ~[0, 1]~ 之间的随机数， 可以使用： ~(float)rand() / RADN_MAX~.

  ~rand()~ 产生的值在 ~[0, RADN_MAX]~ 之间， 而 ~RADN_MAX~ 要求的最小值为 32767.

  瞄了一眼 ~glibc~ 中的 [[http://repo.or.cz/glibc.git/tree/HEAD:/stdlib][实现]], 啧， 还是看书好 (￣▽￣)／

* _Stoul
  这个函数在书中用于实现 ~atoi~, ~atol~, ~strtoul~, ~strtol~ 这几个函数。
  
  #+BEGIN_SRC C
    #include <stdlib.h>
    #include <ctype.h>
    #include <errno.h>
    #include <limits.h>
    #include <stddef.h>
    #include <string.h>

    #define BASE_MAX 36

    static const char digits[] = {"0123456789abcdefghijklmnopqrstuvwxyz"};
    static const char ndigs[BASE_MAX + 1] = {
      0, 0, 33, 21, 17, 13, 12, 11, 11,
      10, 10, 9, 9, 9, 9, 9, 8, 8, 8,
      8, 8, 8, 8, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7
    };

    unsigned long _Stoul(const char* s, char** endptr, int base) {
      const char* sc;
      const char* sd;
      const char* s1;
      const char* s2;
      char sign;
      ptrdiff_t n;  // stddef.h
      unsigned long x, y;

      for (sc = s; isspace(*sc); ++sc);  // 跳过前面的空白字符

      sign = *sc == '-' || *sc == '+' ? *sc++ : '+';  // 判断符号

      if (base < 0 || base == 1 || BASE_MAX < base) {  // 判断进制
        if (endptr) {
          *endptr = (char*)s;
        }
        return 0;
      } else if (base) {
        if (base == 16 && *sc == '0' && (sc[1] == 'x' || sc[1] == 'X')) {
          sc += 2;
        }
      } else if (*sc != 0) {
        base = 10;
      } else if (sc[1] == 'x' || sc[1] == 'X') {
        base = 16, sc += 2;
      } else {
        base = 8;
      }

      for (s1 = sc; *sc == '0'; ++sc);  // 跳过前导 0

      x = 0;
      for (s2 = sc; (sd = memchr(digits, tolower(*sc), base)) != NULL; ++sc) {  // http://www.runoob.com/cprogramming/c-function-memchr.html
        y = x;
        x = x * base + (sd - digits);  // sd - digits 等于 sd 在 digits 的索引
      }

      if (s1 == sc) {
        if (endptr) {
          *endptr = (char*)s;
        }
        return 0;
      }

      n = sc - s2 - ndigs[base];
      if (n < 0) {
        ;
      } else if (0 < n || x < x - sc[-1] || (x - sc[-1]) / base != y) {
        errno = ERANGE;
        x = ULONG_MAX;
      }

      if (sign == '-') {
        x = -x;
      }

      if (endptr) {
        *endptr = (char*)sc;
      }

      return x;
    }
  #+END_SRC

  ~_Stoul~ 的作用是将字符串转换为无符号长整数。

  用惯了 ~Python~ 这类高级语言， 这里看 ~C~ 果然不习惯。

  感觉这些操作就是在内存上直接操刀， 不想其他语言将这些数据抽象为了一个个对象， 而是
  直接操作这些数据本身。

  感觉能力上更加强大， 但可能的风险也确实多一些......
  
  感觉新奇的操作：
  + 类似 ~memchr~ 的函数返回值是指向目标的指针， 使用这个返回值减去数组的基址， 就获得
    了该目标在数组中的索引
  + ~sc[-1]~ 等价于 ~*(sc - 1)~, 没有把握还是不要用的好

  剩下几个函数的实现：
  #+BEGIN_SRC C
    #include <ctype.h>
    #include <errno.h>
    #include <limits.h>
    #include <stdlib.h>


    int atoi(const char* s) {
      return (int)_Stoul(s, NULL, 10);
    }

    long atol(const char* s) {
      return (long)_Stoul(s, NULL, 10);
    }

    unsigned long strtoul(const char* s, char** endptr, int base) {
      return _Stoul(s, endptr, base);
    }

    long strtol(const char*s, char** endptr, int base) {
      const char* sc;
      unsigned long x;

      for (sc = s; isspace(*sc); ++sc);

      x = _Stoul(s, endptr, base);
      if (*sc == '-' && x < LONG_MAX) {
        errno = ERANGE;
        return LONG_MIN;
      } else if (*sc != '-' && LONG_MAX < x) {
        errno = ERANGE;
        return LONG_MAX;
      } else {
        return (long)x;
      }
    }
  #+END_SRC

* _Stod
  ~_Stod~ 是用来实现 ~atof~ 和 ~strtod~ 这两个函数的。

  分别将字符串转换为 ~float~ 和 ~double~ 类型的值。

* 前半部分汇总
  看了这部分 *C 标准库* 函数的作用和实现代码后， 发现， 果然还是对它们的作用和使用更感兴趣。

  而更多函数的实现看起来都很枯燥， 当然也有部分例外。

  枯燥的源码阅读起来收获少还浪费时间， 所以， 后面的源码找感兴趣的浏览一下， 不感兴趣的直接略过。

  顺便汇总一下前面这些函数的原型：
  #+BEGIN_SRC C
    // 求绝对值
    int abs(int num);
    long labs(long num);

    // 同时计算商和余数
    div_t div(int number, int denom);
    ldiv_t ldiv(long number, long denom);

    // 排序和查找
    void qsort(void* base, size_t count, size_t size,
               int (*comp)(const void *, const void *));
    void* bsearch(const void *key, const void *base, size_t count, size_t size,
                   int (*comp)(const void*, const void*));

    // 随机数
    int rand(void);
    void srand(unsigned int seed);

    // 字符串转整数
    int atoi(const char* s);
    long atol(count char* s);
    long strtol(count char* s, char** endptr, int base);
    unsigned long strtoul(const char* s, char** endptr, int base);

    // 字符串转浮点数
    double atof(const char* s);
    double strtod(const char* s, char** endptr);
  #+END_SRC

* 多字节字符函数
  这一部分的函数看的有点懵逼， 虽然之前了解过宽字符和多字节字符的概念， 但是当时的理解
  似乎不是很透彻， 现在这部分函数的使用理解起来都有些困难， 不说理解源码了......

  + int mblen(const char* s, size_t n) :: 确定 ~s~ 指向的的多字节 *字符* 的 *字节数*, 如果 ~s~ 指向的是一个
       多字节 *字符串*, 那么 ~mblen~ 也只会返回头一个多字节字符的字节数， 剩下的字符串不做计算。

       确定一个多字节字符串的长度可以像这样：
       #+BEGIN_SRC C
         #include <string.h>
         #include <stdlib.h>
         #include <locale.h>
         #include <stdio.h>

         // the number of characters in a multibyte string is the sum of mblen()'s
         // note: the simpler approach is mbstowcs(NULL, str, sz)
         size_t strlen_mb(const char* ptr) {
           size_t result = 0;
           const char* end = ptr + strlen(ptr);
           mblen(NULL, 0); // reset the conversion state
           while(ptr < end) {
             int next = mblen(ptr, end - ptr);  // multibyte character size
             if(next == -1) {
               perror("strlen_mb");
               break;
             }
             ptr += next;
             ++result;
           }
           return result;
         }

         int main(void) {
           setlocale(LC_ALL, "en_US.utf8");
           const char* str = "z\u00df\u6c34\U0001f34c";
           printf("The string %s consists of %zu bytes, but only %zu characters\n",
                  str, strlen(str), strlen_mb(str));
         }
       #+END_SRC

       可能的输出：
       #+BEGIN_EXAMPLE
         The string zß水🍌 consists of 10 bytes, but only 4 characters
       #+END_EXAMPLE

       判断当前多字节字符是否结束应该和字符编码的内容相关......

  + int mbtowc(wchar_t* pwc, const char* s, size_t n) :: 将下一个多字节字符转换成宽字符

  + size_t mbstowcs(wchar_t* wcs, const char* s, size_t n) :: 将多字节字符串转换成宽字符串

  + int wctomb(char* s, wchar wchar) :: 将宽字符转换成其多字节表示

  + size_t wcstombs(char* s, const wchar_t* wcs, size_t n) :: 将宽字符串转换成多字节字符串 

  感觉这部分的代码应该抛开字符编码进行理解， 如果不考虑编码的话， 这些函数的作用就是将 *单字节* 数据
  和 *多字节* 数据之间转换， 如 ~char~ 和 ~int~.

  编码影响这个转换规则。

* 内存管理函数
  这应该是相当熟悉的几个函数了：
  #+BEGIN_SRC C
    void* malloc(size_t size);
    void* calloc(size_t nmemb, size_t size);
    void* realloc(void* ptr, size_t size);
    void free(void* ptr);
  #+END_SRC

  在之前的操作系统使实验中已经了解过内存管理函数的实现了， 发现这个实现和我想象的区别有点大......

  函数使用：
  + ~malloc~ 申请指定大小的内存空间， 不初始化
  + ~calloc~ 申请 ~nmemb * size~ 大小的内存空间， 初始化为 0
  + ~realloc~ 将 ~ptr~ 指向的对象的大小改变为由 ~size~ 指定的大小。不初始化。 和实现相关， 返回的地址可能和 ~ptr~ 原地址不同。
  + ~free~ 释放内存

