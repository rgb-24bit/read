#+TITLE:      webapi
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* import
  这个模块是对 ~WSGI~ 的封装， 这是我阅读 ~webpy~ 源码的一个很重要的原因： 了解 ~WSGI~.

  代码量只有 ~500~ 来行， 不多。

  依赖也少， 主要是标准库：
  #+BEGIN_SRC python
    from __future__ import print_function

    import sys, cgi, pprint, urllib
    from .utils import storage, storify, threadeddict, dictadd, intget, safestr

    from .py3helpers import PY2, urljoin, string_types

    try:
        from urllib.parse import unquote, quote
        from http.cookies import Morsel
    except ImportError:
        from urllib import unquote, quote
        from Cookie import Morsel

    from io import StringIO, BytesIO
  #+END_SRC

  有几个不熟悉的模块：
  + ~cgi~ - 了解了一下 ~CGI~ 和 ~WSGI~ 的关系， 看样子处除了 ~WSGI~, ~CGI~ 还需要了解一下
  + ~pprint~ - 更好的输出， 看见过几次了， 这次来了解一下
  + ~Cookie~ - 好像在阅读 [[file:../flasky/README.org][flasky]] 源码的过程中了解了一下 ~Cookie~ 的概念， 这里可以回顾一下

  对于 ~io~ 这个模块， 知道是干啥的， 但是还没用过。

* config
  #+BEGIN_SRC python
    config = storage()
    config.__doc__ = """
    A configuration object for various aspects of web.py.

    `debug`
       : when True, enables reloading, disabled template caching and sets internalerror to debugerror.
    """
  #+END_SRC

  这个是 ~storage~ 的实例吧， ~__doc__~ 影响范围：
  #+BEGIN_SRC python :results output
    class Test(object):
        """ Test __doc__."""
        pass

    t = Test()
    t.__doc__ = """t.__doct__"""

    print(Test.__doc__)
    print(t.__doc__)
  #+END_SRC

  *输出*:
  :  Test __doc__.
  : t.__doct__
 
  还是去了解一下 ~__xxx__~ 的变量好了。

* class HTTPError
  #+BEGIN_SRC python
    class HTTPError(Exception):
        def __init__(self, status, headers={}, data=""):
            ctx.status = status
            for k, v in headers.items():
                header(k, v)
            self.data = data
            Exception.__init__(self, status)
  #+END_SRC

  这么久了， 还没继承过 ~Exception~.

  调用了好几个后面的东西， 先看一下后面再说。

* function _status_code
  动态创建类， 代码阅读起来有点费力：
  #+BEGIN_SRC python
    def _status_code(status, data=None, classname=None, docstring=None):
        if data is None:
            data = status.split(" ", 1)[1]
        classname = status.split(" ", 1)[1].replace(' ', '') # 304 Not Modified -> NotModified
        docstring = docstring or '`%s` status' % status

        def __init__(self, data=data, headers={}):
            HTTPError.__init__(self, status, headers, data)

        # trick to create class dynamically with dynamic docstring.
        return type(classname, (HTTPError, object), {
            '__doc__': docstring,
            '__init__': __init__
        })

    ok = OK = _status_code("200 OK", data="")
    created = Created = _status_code("201 Created")
    accepted = Accepted = _status_code("202 Accepted")
    nocontent = NoContent = _status_code("204 No Content")
  #+END_SRC

  这种创建类的方式的话......

  前面的 ~_~ 还是很有必要的 ！

* class Redirect
  ~HTTPError~ 的子类， 看类的名字我感觉猜不出来。

  简单的看了一下代码， 目测属于我的知识盲区范围了， 补充一下相关知识在继续。

