#+TITLE:      webapi
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#reread][Reread]]
- [[#import][import]]
- [[#instances][instances]]
  - [[#config][config]]
  - [[#ctx][ctx]]
- [[#class-httperror][class HTTPError]]
  - [[#function-header][function header]]
- [[#function-_status_code][function _status_code]]
- [[#class-for-status-code][class for status code]]
- [[#function-rawinput][function rawinput]]

* Reread
  前一段时间尝试了阅读 ~webapi~ 模块的源码， 但由于相关知识不足的问题导致阅读质量
  很差， 因此选择重读。

  前一段时间的阅读笔记： [[file:trash/webapi.org][webapi]].
  
* import
  这个模块依赖的模块：
  #+BEGIN_SRC python
    from __future__ import print_function

    import sys, cgi, pprint, urllib
    from .utils import storage, storify, threadeddict, dictadd, intget, safestr

    from .py3helpers import PY2, urljoin, string_types

    try:
        from urllib.parse import unquote, quote
        from http.cookies import Morsel
    except ImportError:
        from urllib import unquote, quote
        from Cookie import Morsel

    from io import StringIO, BytesIO
  #+END_SRC

  依赖的模块中， ~utils~ 和 ~py3helpers~ 的源码已经读过了， 问题不大。

  ~cgi~ 和 ~pprint~ 这两个模块不太熟悉， 可以了解一下。

  ~urllib~ 了解过， 但用的比较少， 不是很熟悉。

  ~Cookie~ 就没用过了。

  ~io~ 这个模块目前就用过 ~io.open~.

* instances
  前一次阅读的过程中对这些 *实例* 的调用产生了一些疑惑， 后来尝试了一下，
  发现其他模块中 ~import~ 这些实例的话， 不同模块 ~import~ 的是同一个对象。

  也就是说在一个模块中对 *实例* 的属性进行了修改， 会反应到同样 ~import~ 了这个 *实例*
  的模块中， 包括当前模块本身。

  而 ~ctx~ 对象的特殊性， 使得它在除了 *主线程* 中的唯一 *实例* 外， 在其他线程中还会单独存在
  一个实例， 保存那个线程下的上下文。

** config
   #+BEGIN_SRC python
     config = storage()
     config.__doc__ = """
     A configuration object for various aspects of web.py.

     `debug`
        : when True, enables reloading, disabled template caching and sets internalerror to debugerror.
     """
   #+END_SRC

   配置用的一个实例， 简单直接。

** ctx
   #+BEGIN_SRC python
     ctx = context = threadeddict()

     ctx.__doc__ = """
     A `storage` object containing various information about the request:

     `environ` (aka `env`)
        : A dictionary containing the standard WSGI environment variables.

     `host`
        : The domain (`Host` header) requested by the user.

     `home`
        : The base path for the application.

     `ip`
        : The IP address of the requester.

     `method`
        : The HTTP method used.

     `path`
        : The path request.

     `query`
        : If there are no query arguments, the empty string. Otherwise, a `?` followed
          by the query string.

     `fullpath`
        : The full path requested, including query arguments (`== path + query`).

     ### Response Data

     `status` (default: "200 OK")
        : The status code to be used in the response.

     `headers`
        : A list of 2-tuples to be used in the response.

     `output`
        : A string to be used as the response.
     """
   #+END_SRC

   应该是用来保存 *上下文* 的对象， 而且是 ~threadeddict~ 的 *实例*.

   ~threadeddict~ 是在 ~utils~ 模块中定义的， 该对象的实例在各个线程下相对独立， 互不影响。

   也就是说 ~ctx~ 可以分别保存多个线程的上下文， 互不影响， 且调用属性方式相同。

* class HTTPError
  一个自定义异常:
  #+BEGIN_SRC python
    class HTTPError(Exception):
        def __init__(self, status, headers={}, data=""):
            ctx.status = status
            for k, v in headers.items():
                header(k, v)
            self.data = data
            Exception.__init__(self, status)
  #+END_SRC

  异常的 *构造函数* 中， 修改了 ~ctx.status~, 并将 ~data~ 绑定到自身的实例上。

  也就是说， 当出现 ~HTTPError~ 的时候， 会将 *状态码* 保存到当前的上下文之中。

  也可以预测， 使用 ~HTTPError~ 的地方， 必然知道返回的 *状态码*.

** function header
   *构造函数* 中使用了 ~header~ 函数：
   #+BEGIN_SRC python
     def header(hdr, value, unique=False):
         """
         Adds the header `hdr: value` with the response.

         If `unique` is True and a header with that name already exists,
         it doesn't add a new one.
         """
         hdr, value = safestr(hdr), safestr(value)
         # protection against HTTP response splitting attack
         if '\n' in hdr or '\r' in hdr or '\n' in value or '\r' in value:
             raise ValueError('invalid characters in header')
         if unique is True:
             for h, v in ctx.headers:
                 if h.lower() == hdr.lower(): return

         ctx.headers.append((hdr, value))
   #+END_SRC

   很明显， 这个是用来将 *响应头* 保存到上下文中的函数。

   首先， 将头信息的键值转换为 ~str~, 包整内部数据类型的统一。

   *头信息* 中的数据是不存在 *换行符* 的， 所以进行了检查。

   循环中判断头信息的 *键* 是否重复。

   ~headers~ 是一个 ~list~.

   目前可以明白 ~HTTPError~ 的基本工作流程了：
   1. 将状态码保存到当前上下文
   2. 更新当前上下文的头信息
   3. 将 ~data~ 绑定到异常实例

* function _status_code
  用来构造类的一个函数：
  #+BEGIN_SRC python
    def _status_code(status, data=None, classname=None, docstring=None):
        if data is None:
            data = status.split(" ", 1)[1]
        classname = status.split(" ", 1)[1].replace(' ', '') # 304 Not Modified -> NotModified
        docstring = docstring or '`%s` status' % status

        def __init__(self, data=data, headers={}):
            HTTPError.__init__(self, status, headers, data)

        # trick to create class dynamically with dynamic docstring.
        return type(classname, (HTTPError, object), {
            '__doc__': docstring,
            '__init__': __init__
        })
  #+END_SRC

  使用这个函数创建了四个类：
  #+BEGIN_SRC python
    ok = OK = _status_code("200 OK", data="")
    created = Created = _status_code("201 Created")
    accepted = Accepted = _status_code("202 Accepted")
    nocontent = NoContent = _status_code("204 No Content")
  #+END_SRC
  
  感觉吧， 函数前面的 ~_~ 是很有必要的 ！

* class for status code
  针对 *状态码* 的异常类：
  #+BEGIN_SRC python
    __all__ = [
        "HTTPError",

        # 200, 201, 202, 204
        "OK", "Created", "Accepted", "NoContent",
        "ok", "created", "accepted", "nocontent",

        # 301, 302, 303, 304, 307
        "Redirect", "Found", "SeeOther", "NotModified", "TempRedirect",
        "redirect", "found", "seeother", "notmodified", "tempredirect",

        # 400, 401, 403, 404, 405, 406, 409, 410, 412, 415, 451
        "BadRequest", "Unauthorized", "Forbidden", "NotFound", "NoMethod", "NotAcceptable", "Conflict", "Gone", "PreconditionFailed", "UnsupportedMediaType", "UnavailableForLegalReasons",
        "badrequest", "unauthorized", "forbidden", "notfound", "nomethod", "notacceptable", "conflict", "gone", "preconditionfailed", "unsupportedmediatype", "unavailableforlegalreasons",

        # 500
        "InternalError",
        "internalerror",
    ]
  #+END_SRC
  
  看 ~__all__~ 变量的部分就可以明白有多少个类了。

  这部分的代码主要就是针对不同的状态码的操作， 相当繁琐。

  但是浏览还是有助于了解 ~HTTP~ 协议相关的内容。

  留个链接： [[https://github.com/webpy/webpy/blob/master/web/webapi.py#L54][HTTPError]].

* function rawinput
  和 ~raw_input~ 就差个 ~_~:
  #+BEGIN_SRC python
    def rawinput(method=None):
        """Returns storage object with GET or POST arguments.
        """
        method = method or "both"

        def dictify(fs):
            # hack to make web.input work with enctype='text/plain.
            if fs.list is None:
                fs.list = []

            return dict([(k, fs[k]) for k in fs.keys()])

        e = ctx.env.copy()
        a = b = {}

        if method.lower() in ['both', 'post', 'put']:
            if e['REQUEST_METHOD'] in ['POST', 'PUT']:
                if e.get('CONTENT_TYPE', '').lower().startswith('multipart/'):
                    # since wsgi.input is directly passed to cgi.FieldStorage,
                    # it can not be called multiple times. Saving the FieldStorage
                    # object in ctx to allow calling web.input multiple times.
                    a = ctx.get('_fieldstorage')
                    if not a:
                        fp = e['wsgi.input']
                        a = cgi.FieldStorage(fp=fp, environ=e, keep_blank_values=1)
                        ctx._fieldstorage = a
                else:
                    d = data()
                    if PY2 and isinstance(d, unicode):
                        d = d.encode('utf-8')
                    fp = BytesIO(d)
                    a = cgi.FieldStorage(fp=fp, environ=e, keep_blank_values=1)
                a = dictify(a)

        if method.lower() in ['both', 'get']:
            e['REQUEST_METHOD'] = 'GET'
            b = dictify(cgi.FieldStorage(environ=e, keep_blank_values=1))

        def process_fieldstorage(fs):
            if isinstance(fs, list):
                return [process_fieldstorage(x) for x in fs]
            elif fs.filename is None:
                return fs.value
            else:
                return fs

        return storage([(k, process_fieldstorage(v)) for k, v in dictadd(b, a).items()])
  #+END_SRC
 
  首先是嵌套函数 ~dictify~, 目测和 ~Storage~ 对象有关。

  关于 ~Storage~ 的内容忘了不少， 重新打开 ~utils~ 看了一下， 发现
  ~Storage~ 是继承自 ~dict~ 的， 并重构的 *设置属性* 的魔法方法。

  使得设置与获取属性的时候就等价于设置获取字典的键值。

  ~utils~ 中定义了一个函数 ~storify~, 将一个映射对象转化为 ~storage~ 对象。

  这个 ~dictify~ 的部分作用应该就是将 ~storage~ 转化为 ~dict~.

  然后， 获取了 *上下文* 中的 ~env~ 对象的浅拷贝。

  ~a = b = {}~, a 和 b 都是同一个对象。

  emmm, 用到 ~cgi~ 了， 先去了解一下。

