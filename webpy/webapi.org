#+TITLE:      webapi
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#import][import]]
- [[#config][config]]
- [[#class-httperror][class HTTPError]]
  - [[#instance-ctx][instance ctx]]
  - [[#function-header][function header]]
  - [[#理解][理解]]
- [[#function-_status_code][function _status_code]]
- [[#class-redirect][class Redirect]]

* import
  这个模块是对 ~WSGI~ 的封装， 这是我阅读 ~webpy~ 源码的一个很重要的原因： 了解 ~WSGI~.

  代码量只有 ~500~ 来行， 不多。

  依赖也少， 主要是标准库：
  #+BEGIN_SRC python
    from __future__ import print_function

    import sys, cgi, pprint, urllib
    from .utils import storage, storify, threadeddict, dictadd, intget, safestr

    from .py3helpers import PY2, urljoin, string_types

    try:
        from urllib.parse import unquote, quote
        from http.cookies import Morsel
    except ImportError:
        from urllib import unquote, quote
        from Cookie import Morsel

    from io import StringIO, BytesIO
  #+END_SRC

  有几个不熟悉的模块：
  + ~cgi~ - 了解了一下 ~CGI~ 和 ~WSGI~ 的关系， 看样子处除了 ~WSGI~, ~CGI~ 还需要了解一下
  + ~pprint~ - 更好的输出， 看见过几次了， 这次来了解一下
  + ~Cookie~ - 好像在阅读 [[file:../flasky/README.org][flasky]] 源码的过程中了解了一下 ~Cookie~ 的概念， 这里可以回顾一下

  对于 ~io~ 这个模块， 知道是干啥的， 但是还没用过。

* config
  #+BEGIN_SRC python
    config = storage()
    config.__doc__ = """
    A configuration object for various aspects of web.py.

    `debug`
       : when True, enables reloading, disabled template caching and sets internalerror to debugerror.
    """
  #+END_SRC

  这个是 ~storage~ 的实例吧， ~__doc__~ 影响范围：
  #+BEGIN_SRC python :results output
    class Test(object):
        """ Test __doc__."""
        pass

    t = Test()
    t.__doc__ = """t.__doct__"""

    print(Test.__doc__)
    print(t.__doc__)
  #+END_SRC

  *输出*:
  :  Test __doc__.
  : t.__doct__
 
  还是去了解一下 ~__xxx__~ 的变量好了。

* class HTTPError
  #+BEGIN_SRC python
    class HTTPError(Exception):
        def __init__(self, status, headers={}, data=""):
            ctx.status = status
            for k, v in headers.items():
                header(k, v)
            self.data = data
            Exception.__init__(self, status)
  #+END_SRC

  这么久了， 还没继承过 ~Exception~.

  调用了好几个后面的东西， 先看一下后面再说。

  瞄了一眼后面的代码， 大批量的 ~HTTPError~ 的子类， 还是先搞清楚这个类再说吧......

** instance ctx
   #+BEGIN_SRC python
     ctx = context = threadeddict()

     ctx.__doc__ = """
     A `storage` object containing various information about the request:

     `environ` (aka `env`)
        : A dictionary containing the standard WSGI environment variables.

     `host`
        : The domain (`Host` header) requested by the user.

     `home`
        : The base path for the application.

     `ip`
        : The IP address of the requester.

     `method`
        : The HTTP method used.

     `path`
        : The path request.

     `query`
        : If there are no query arguments, the empty string. Otherwise, a `?` followed
          by the query string.

     `fullpath`
        : The full path requested, including query arguments (`== path + query`).

     ### Response Data

     `status` (default: "200 OK")
        : The status code to be used in the response.

     `headers`
        : A list of 2-tuples to be used in the response.

     `output`
        : A string to be used as the response.
     """
   #+END_SRC

   这是 ~ctx~, 翻到 ~utils.py~ 看了一下 ~threadeddict~...

   当时没看仔细， 目前对多线程相关的内容还是有点僵硬。

   但是这个类还涉及到了 *类属性* 和 *实例属性* 的内容。

   再次了解学习了相关的内容， 目前对 *类属性* 和 *实例* 属性的理解是：
   + *类* 和 *实例* 都是对象
   + *类* 和 *实例* 都存在各自的属性和方法
   + *实例* 包含了 *类* 的属性和方法
   + *类属性* 不直接绑定到 *实例*
   + 当获取不属于 *实例* 的属性或方法时会尝试从 *类* 获取该属性， 因此 *类* 属性的变化会影响所有没有绑定该属性的 *实例*
   + 当设置 *实例* 的属性时， 该属性会 *绑定* 到 *实例*, 此时， *类* 的属性 和 *实例* 的属性相互独立

   再从头看 ~ThreadedDict~ 这个类， *类属性* ~_instances~ 应该不会绑定到单独的 *实例*, 因此可以对
   各个线程下的 ~instances~ 进行良好的处理。

   突然发现， ~ThreadedDict~ 这个类很好很强大！

** function header
   #+BEGIN_SRC python
     def header(hdr, value, unique=False):
         """
         Adds the header `hdr: value` with the response.

         If `unique` is True and a header with that name already exists,
         it doesn't add a new one.
         """
         hdr, value = safestr(hdr), safestr(value)
         # protection against HTTP response splitting attack
         if '\n' in hdr or '\r' in hdr or '\n' in value or '\r' in value:
             raise ValueError('invalid characters in header')
         if unique is True:
             for h, v in ctx.headers:
                 if h.lower() == hdr.lower(): return

         ctx.headers.append((hdr, value))
   #+END_SRC

   这个应该设置 [[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers][HTTP Headers]] 用的。

** 理解
   可以看到， ~ThreadedDict~ 对设置属性很宽松。

   ~ctx.status~ 保存当前上下文的 ~status~.

   同时将 ~headers~ 保存到上下文的 ~headers~.

* function _status_code
  动态创建类， 代码阅读起来有点费力：
  #+BEGIN_SRC python
    def _status_code(status, data=None, classname=None, docstring=None):
        if data is None:
            data = status.split(" ", 1)[1]
        classname = status.split(" ", 1)[1].replace(' ', '') # 304 Not Modified -> NotModified
        docstring = docstring or '`%s` status' % status

        def __init__(self, data=data, headers={}):
            HTTPError.__init__(self, status, headers, data)

        # trick to create class dynamically with dynamic docstring.
        return type(classname, (HTTPError, object), {
            '__doc__': docstring,
            '__init__': __init__
        })

    ok = OK = _status_code("200 OK", data="")
    created = Created = _status_code("201 Created")
    accepted = Accepted = _status_code("202 Accepted")
    nocontent = NoContent = _status_code("204 No Content")
  #+END_SRC

  这种创建类的方式的话......

  前面的 ~_~ 还是很有必要的 ！

* class Redirect
  ~HTTPError~ 的子类， 看类的名字我感觉猜不出来。

  简单的看了一下代码， 目测属于我的知识盲区范围了， 补充一下相关知识在继续。

