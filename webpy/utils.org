#+TITLE:      utils
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#import][import]]
- [[#class-storage][class Storage]]
  - [[#function-storify][function storify]]
  - [[#function-safeunicode][function safeunicode]]
- [[#class-counter][class Counter]]
- [[#iters][iters]]
- [[#function-strips][function strips]]
- [[#function-timelimit][function timelimit]]
- [[#class-memoize][class Memoize]]
- [[#class-_re_subm_proxy][class _re_subm_proxy]]
  - [[#function-re_subm][function re_subm]]
- [[#function-group][function group]]
- [[#function-uniq][function uniq]]
- [[#function-iterview][function iterview]]
- [[#class-iterbetter][class IterBetter]]
- [[#function-safeiter][function safeiter]]
- [[#function-safewrite][function safewrite]]
- [[#function-dictxxx][function dictxxx]]
- [[#function-requeue][function requeue]]
- [[#function-restack][function restack]]
- [[#function-listget][function listget]]
- [[#function-intget][function intget]]
- [[#function-numify][function numify]]
- [[#function-denumify][function denumify]]
- [[#function-commify][function commify]]
- [[#function-dateify][function dateify]]
- [[#function-nthstr][function nthstr]]
- [[#function-cond][function cond]]

* import
  #+BEGIN_SRC python
    from __future__ import print_function

    __all__ = [...]

    import re, sys, time, threading, itertools, traceback, os

    import subprocess
    import datetime
    from threading import local as threadlocal

    from .py3helpers import PY2, itervalues, iteritems, text_type, string_types, imap, is_iter

    try:
        from StringIO import StringIO
    except ImportError:
        from io import StringIO
  #+END_SRC

  ~__all__~ 里面的东西是真滴多， 这个模块源码的阅读要点时间了......

  导入的模块里有几个不熟悉的：
  + itertools :: 用于高效循环的迭代函数集合， 简单的看了一下， 好东西， 了解一下
  + traceback :: 可以用于获取详细的异常信息
  + StringIO :: 在内存中读写 ~str~, 感觉好像可以用 /@_@/
  + threading & subprocess :: 貌似自己现在的程序用不上 /QAQ/

* class Storage
  这个类实现的功能是我一直想要的。
  #+BEGIN_SRC python
    class Storage(dict):
        def __getattr__(self, key):
            try:
                return self[key]
            except KeyError as k:
                raise AttributeError(k)

        def __setattr__(self, key, value): 
            self[key] = value

        def __delattr__(self, key):
            try:
                del self[key]
            except KeyError as k:
                raise AttributeError(k)

        def __repr__(self):
            return '<Storage ' + dict.__repr__(self) + '>'

    storage = Storage
  #+END_SRC

  实现还是很简单的， 可以这样操作字典了：
  #+BEGIN_SRC python
    >>> obj = storage(a = 1)
    >>> obj.a
    1
    >>> obj['a']
    1
    >>> obj.b = 10
    >>> obj.b
    10
  #+END_SRC

** function storify
   这个函数的作用是将一个映射对象转化为 ~storage~ 对象， 同时允许通过
   位置参数和关键字参数设置返回的 ~storage~ 对象的值。
   
   #+BEGIN_SRC python
     _unicode = defaults.pop('_unicode', False)

     # if _unicode is callable object, use it convert a string to unicode.
     to_unicode = safeunicode
     if _unicode is not False and hasattr(_unicode, "__call__"):
         to_unicode = _unicode
   #+END_SRC
   
   这段代码， 应该是和其他地方进行配合吧， 允许从映射中传入 ~to_unicode~ 的方法。
   
   对于 ~Python2~ 和 ~Python3~ 中 ~str~ 代表的字符串类型不同的解决方案， 默认使用 ~safeunicode~
   函数进行转换。 这个函数就定义在这个模块中： [[#function-safeunicode][safeunicode]]

   #+BEGIN_SRC python
     def unicodify(s):
         if _unicode and isinstance(s, str): return to_unicode(s)
         else: return s
   #+END_SRC

   依赖 ~to_unicode~, 定义了这个转换为 ~unicode~ 的函数， ~ify~ 后缀的意思是 ~使...变得...~

  #+BEGIN_SRC python
    def getvalue(x):
        if hasattr(x, 'file') and hasattr(x, 'value'):
            return x.value
        elif hasattr(x, 'value'):
            return unicodify(x.value)
        else:
            return unicodify(x)
  #+END_SRC

  保证程序内部的值的类型都是 ~unicode~, 只是， 什么对象具有 ~file~ 属性呢？

  #+BEGIN_SRC python
    def storify(mapping, *requireds, **defaults):
        ...
        for key in requireds + tuple(mapping.keys()):
            ...
        for (key, value) in iteritems(defaults):
            ...
  #+END_SRC

  这里是 ~storify~ 函数传入的参数列表， 分别使用了两个循环来处理后边的两个参数。
  循环内部大量使用 ~isinstance~ 函数， 在我看来不怎么有用的函数还是很有用的......

** function safeunicode   
   #+BEGIN_SRC python
     def safeunicode(obj, encoding='utf-8'):
         t = type(obj)
         if t is text_type:
             return obj
         elif t is bytes:
             return obj.decode(encoding)
         elif t in [int, float, bool]:
             return unicode(obj)
         else:
             return unicode(obj)

     def safestr(obj, encoding='utf-8'):
         if PY2 and isinstance(obj, unicode):
             return obj.encode(encoding)
         elif is_iter(obj):
             return imap(safestr, obj)
         else:
             return str(obj)

     if not PY2:
         safeunicode = safestr
   #+END_SRC

   这是实现 ~safeunicode~ 的源码， ~py3helpers~ 对类型的兼容处理在这里起到作用了。

   ~text_type~ 是 ~unicode~, 这里才发现可以像 ~t is text_type~ 这样判断类型。

   #+BEGIN_SRC python
     >>> type(dict)
     <type 'type'>
     >>> type(dict) is dict
     False
     >>> d = dict()
     >>> type(d)
     <type 'dict'>
     >>> type(d) is dict
     True
   #+END_SRC

   尝试了一下， ~type~ 返回对象的类型， ~dict~ 的类型是 ~type~, ~dict~ 实例的类型才是 ~dict~.

   ~safestr~ 函数这里晕了一下， 看了几遍， 意思应该就是对 ~Python2~ 和 ~Python3~ 的兼容了。

   将原有的对象安全的转换回 ~str~, 由于 ~Python2~ 和 ~Python3~ 中 ~str~ 的类型不相同， 所以需要绕一下。

   而 ~Python3~ 中， ~str~ 就是 ~unicode~, 所以 ~safeunicode = safestr~.

* class Counter
  这个类继承自 ~class storage~, 功能和 ~collections~ 模块的 ~Counter~ 有点类似， 但也有很多不同。

  实现的几个方法：

  #+BEGIN_SRC python
    # key 键值 + 1
    def add(self, n):
        self.setdefault(n, 0)
        self[n] += 1

    # 返回 value 最大的 key
    def most(self):
        m = max(itervalues(self))
        return [k for k, v in iteritems(self) if v == m]

    # 返回 value 最小的 key
    def least(self):
        m = min(self.itervalues())
        return [k for k, v in iteritems(self) if v == m]

    # 返回 key 的 value 在所有 values 中占得比例
    def percent(self, key):
        return float(self[key])/sum(self.values())

    # 返回排序的 keys
    def sorted_keys(self):
        return sorted(self.keys(), key=lambda k: self[k], reverse=True)

    # 返回排序的 values
    def sorted_values(self):
        return [self[k] for k in self.sorted_keys()]

    # 返回排序的 (key, value), 根据 key 排序
    def sorted_items(self):
        return [(k, self[k]) for k in self.sorted_keys()]
  #+END_SRC

  ~py3helpers~ 中对 ~dict~ 的 ~iter*~ 方法的处理真的很有用啊 ！

  #+BEGIN_SRC python
    counter = Counter
  #+END_SRC

* iters
  #+BEGIN_SRC python
    iters = [list, tuple, set, frozenset]
    class _hack(tuple): pass
    iters = _hack(iters)
    iters.__doc__ = """
    A list of iterable items (like lists, but not strings). Includes whichever
    of lists, tuples, sets, and Sets are available in this version of Python.
    """
  #+END_SRC

  第一眼， 为什么不直接就用 ~tuple~, 还要继承 ~tuple~, 然后才发现， ~__doc__~
  貌似是 *类变量*, 而且 ~tuple~ 的 ~__doc__~ 还是只读变量。

  还是继承好。

* function strips
  ~python str~ 对象自身就有 ~strip~ 方法， 经常用来去除不必要的空白字符。

  这里实现了一个高级的版本：
  #+BEGIN_SRC python
    def _strips(direction, text, remove):
        if isinstance(remove, iters):
            for subr in remove:
                text = _strips(direction, text, subr)
            return text

        if direction == 'l':
            if text.startswith(remove):
                return text[len(remove):]
        elif direction == 'r':
            if text.endswith(remove):
                return text[:-len(remove)]
        else:
            raise ValueError("Direction needs to be r or l.")
        return text
  #+END_SRC

  对于 ~for~ 循环那一段， ~Python~ 没有局部作用域是真滴强。

  后面的实现还是比较简单的。

  根据这个方法， 相继实现了：
  #+BEGIN_SRC python
    def lstrips(text, remove):
    def rstrips(text, remove):
    def strips(text, remove):
        return rstrips(lstrips(text, remove), remove)
  #+END_SRC

  最后的 ~strips~ 的实现感觉.

* function timelimit
  ~Python~ 之中， 一切皆是对象。 感觉这句话在这里有一些体现：
  #+BEGIN_SRC python
    def timelimit(timeout):
        def _1(function):
            def _2(*args, **kw):
                class Dispatch(threading.Thread):
                    def __init__(self):
                        threading.Thread.__init__(self)
                        self.result = None
                        self.error = None

                        self.setDaemon(True)
                        self.start()

                    def run(self):
                        try:
                            self.result = function(*args, **kw)
                        except:
                            self.error = sys.exc_info()

                c = Dispatch()
                c.join(timeout)
                if c.isAlive():
                    raise RuntimeError('took too long')
                if c.error:
                    raise c.error[1]
                return c.result
            return _2
        return _1
  #+END_SRC

  这个函数的使用流程：
  1. 定义一个函数 ~func~
  2. 通过 ~timelimit(timeout)~ 得到新的函数 ~func1~
  3. 通过 ~func1(func)~ 得到新的函数 ~func2~
  4. 使用 ~func2~
  
  简化的流程就是： ~timelimit(timeout)(func)()~.

  看到这一连串的括号， 嗯， 可以， 很强势。

  对于这个函数的作用， 我想我需要去了解一下 *多线程* 的内容先。

  了解了一下， 这个函数的代码看起来还是有点绕......

  首先， 最外层的 ~timelimit(timeout)~ 设置好超时时间， 获得 ~_1~. 然后通过 ~_1(function)~ 获得
   ~_2~. 在 ~_2~ 中， 继承 ~threading.Thread~ 的 ~class Dispatch~ 用来运行 ~function~. 最开始设置的
   超时时间用于判断 ~function~ 的执行是否在指定的时间内完成。

   嗯， 功能大概就是用来构建一个 *在指定之间内完成指定任务的函数*.

* class Memoize
  接着绕啊绕......

  首先， 是魔法方法 ~__call__~. 这个魔法方法允许向访问方法那样访问类的实例：
  #+BEGIN_SRC python
    class A(object):
        def __init__(self):
            self.num = 0

        def __call__(self, *args, **kwargs):
            self.num += 1
            return self.num

    num = A()
    print(num())
    print(num())
    print(num())
  #+END_SRC

  然后， 是这个类来干嘛的 ！
  #+BEGIN_SRC python
    class Memoize:
        def __init__(self, func, expires=None, background=True):
            self.func = func
            self.cache = {}
            self.expires = expires
            self.background = background
            self.running = {}

        def __call__(self, *args, **keywords):
            key = (args, tuple(keywords.items()))
            if not self.running.get(key):
                self.running[key] = threading.Lock()
            def update(block=False):
                if self.running[key].acquire(block):
                    try:
                        self.cache[key] = (self.func(*args, **keywords), time.time())
                    finally:
                        self.running[key].release()

            if key not in self.cache:
                update(block=True)
            elif self.expires and (time.time() - self.cache[key][1]) > self.expires:
                if self.background:
                    threading.Thread(target=update).start()
                else:
                    update()
            return self.cache[key][0]
  #+END_SRC

  这个类会保存每次运算的结果， 根据调用方法的参数。

  保存运算结果时会一同保存得到结果的时间， 如果调用时定义了 ~expires~, 会根据调用的时间和上一次得到
  的结果差来判断是否需要更新结果。

  如果定义了 ~background=True~, 会将计算结果的过程放入一个单独的线程进行。

  对于 ~update~ 中的线程锁， 继续补充知识 !

  看了一下， 完全理解还是有一定难度， 但粗略的理解还是可以了。

  ~cache~ 的更新依赖于 ~running~ 中的键， ~running~ 中的每一个键都是一个锁对象。 通过 ~running~
  每个键的锁对象来实现对 ~cache~ 中的数据的保护。

  #+BEGIN_SRC python 
    memoize = Memoize

    re_compile = memoize(re.compile) #@@ threadsafe?
    re_compile.__doc__ = """
    A memoized version of re.compile.
    """
  #+END_SRC
  
  保存每次 ~re.compile~ 的结果。

* class _re_subm_proxy
  #+BEGIN_SRC python
    class _re_subm_proxy:
        def __init__(self): 
            self.match = None
        def __call__(self, match): 
            self.match = match
            return ''
  #+END_SRC
  很明显， 这个类是服务于后面的内容的。

** function re_subm
   #+BEGIN_SRC python
     def re_subm(pat, repl, string):
         compiled_pat = re_compile(pat)
         proxy = _re_subm_proxy()
         compiled_pat.sub(proxy.__call__, string)
         return compiled_pat.sub(repl, string), proxy.match
   #+END_SRC

   这段代码让我最疑惑的是： ~compiled_pat.sub(proxy.__call__, string)~. 容易明白的是， ~compiled_pat~
   应该是一个 ~compile~ 对象， 可是 ~sub~ 的第一个参数是什么鬼 ？

   看了一下文档， ~sub~ 的第一个方法除了可以是字符串以外， 还可以是一个方法， 这个方法只能接受
   一个参数 ~match~.

* function group
  函数功能： 序列分组
  #+BEGIN_SRC python
    def group(seq, size): 
        def take(seq, n):
            for i in range(n):
                yield next(seq)

        if not hasattr(seq, 'next'):  
            seq = iter(seq)
        while True: 
            x = list(take(seq, size))
            if x:
                yield x
            else:
                break
  #+END_SRC
  根据指定的 ~size~ 将序列 ~seq~ 分组。

  对于 ~hasattr(seq, 'next')~ 这一段， 之前在 ~py3helpers~ 中都对 ~next~ 和 ~__next__~ 进行了区分， 这里没有。
  虽然感觉有些有些奇怪， 但是这一点貌似没有影响。 我觉得干脆直接改成 ~iter(seq)~ 应该也不会出错。

  另外， ~iter~ 和 ~next~ 的一种用法还是很有启示的。

* function uniq
  函数作用： 去重
  #+BEGIN_SRC python
    def uniq(seq, key=None):
        key = key or (lambda x: x)
        seen = set()
        result = []
        for v in seq:
            k = key(v)
            if k in seen:
                continue
            seen.add(k)
            result.append(v)
        return result
  #+END_SRC

  第一行： ~key = key or (lambda x: x)~. 还可以这样的吗 ？

  尝试：
  #+BEGIN_SRC python
    >>> x = 10
    >>> x = x or 1
    >>> x
    10
    >>> x = None
    >>> x = x or 1
    >>> x
    1
    >>> x = None or None or 1
    >>> x
    1
  #+END_SRC

  找到文档了： [[https://docs.python.org/2.7/reference/expressions.html#boolean-operations][Boolean operations]]

  不愧是我大 ~Python~.

  后面的代码虽然第一眼感觉可以简化， 毕竟去重很快。 仔细一看， 还保留了原始序列的顺序！ 高级

* function iterview 
  #+BEGIN_SRC python
    def iterview(x):
       """
       Takes an iterable `x` and returns an iterator over it
       which prints its progress to stderr as it iterates through.
       """
       WIDTH = 70

       def plainformat(n, lenx):
           return '%5.1f%% (%*d/%d)' % ((float(n)/lenx)*100, len(str(lenx)), n, lenx)

       def bars(size, n, lenx):
           val = int((float(n)*size)/lenx + 0.5)
           if size - val:
               spacing = ">" + (" "*(size-val))[1:]
           else:
               spacing = ""
           return "[%s%s]" % ("="*val, spacing)

       def eta(elapsed, n, lenx):
           if n == 0:
               return '--:--:--'
           if n == lenx:
               secs = int(elapsed)
           else:
               secs = int((elapsed/n) * (lenx-n))
           mins, secs = divmod(secs, 60)
           hrs, mins = divmod(mins, 60)

           return '%02d:%02d:%02d' % (hrs, mins, secs)

       def format(starttime, n, lenx):
           out = plainformat(n, lenx) + ' '
           if n == lenx:
               end = '     '
           else:
               end = ' ETA '
           end += eta(time.time() - starttime, n, lenx)
           out += bars(WIDTH - len(out) - len(end), n, lenx)
           out += end
           return out

       starttime = time.time()
       lenx = len(x)
       for n, y in enumerate(x):
           sys.stderr.write('\r' + format(starttime, n, lenx))
           yield y
       sys.stderr.write('\r' + format(starttime, n+1, lenx) + '\n')
  #+END_SRC

  这个函数的作用很明确， 输出效果很 ~nice~.

* class IterBetter
  这个类的话， 先了解几个 *魔法方法* 吧。

  ~__setattr__~, 这个类里面并没有出现这个方法， 但是对 ~Python~ 设置
  属性的错误理解让我重新学习了一下这个方法。

  设置类实例的属性的时候， 会调用 ~__setattr__~ 的方法， 如果设置的属性
  为 ~__setattr__~ 不允许的值会引发错误。 哪怕是在 ~__init__~ 中。

  如果没有编写 ~__setattr__~ 方法， 那么设置任意属性的行为都是允许的。

  而内置类型应该都对 ~__setattr__~ 进行了设置， 不能直接添加内置属性以外的属性。

  ~__nonzero__~, 执行 ~bool(obj)~ 时会调用这个方法， ~Python3~ 改为了 ~__bool__~.

  这个类里面是这样操作的：
  #+BEGIN_SRC python
    def __nonzero__(self):
        ...

    __bool__ = __nonzero__
  #+END_SRC

  一切皆是对象啊 ！

  其他功能的实现的话， 没有太多好说的了：
  #+BEGIN_SRC python 
    class IterBetter:
        def __init__(self, iterator): 
            self.i, self.c = iterator, 0

        def first(self, default=None):
            try:
                return next(iter(self))
            except StopIteration:
                return default

        def __iter__(self): 
            if hasattr(self, "_head"):
                yield self._head

            while 1:    
                yield next(self.i)
                self.c += 1

        def __getitem__(self, i):
            #todo: slices
            if i < self.c: 
                raise IndexError("already passed "+str(i))
            try:
                while i > self.c: 
                    next(self.i)
                    self.c += 1
                # now self.c == i
                self.c += 1
                return next(self.i)
            except StopIteration: 
                raise IndexError(str(i))
            
        def __nonzero__(self):
            if hasattr(self, "__len__"):
                return self.__len__() != 0
            elif hasattr(self, "_head"):
                return True
            else:
                try:
                    self._head = next(self.i)
                except StopIteration:
                    return False
                else:
                    return True

        __bool__ = __nonzero__

    iterbetter = IterBetter
  #+END_SRC
  
* function safeiter 
  #+BEGIN_SRC python
    def safeiter(it, cleanup=None, ignore_errors=True):
        def next():
            while True:
                try:
                    return next(it)
                except StopIteration:
                    raise
                except:
                    traceback.print_exc()

        it = iter(it)
        while True:
            yield next()
  #+END_SRC

  所以另外两个参数是什么用 ？

* function safewrite
  #+BEGIN_SRC python
    def safewrite(filename, content):
        f = file(filename + '.tmp', 'w')
        f.write(content)
        f.close()
        os.rename(f.name, filename)
  #+END_SRC
  
  emmm, 如果 ~filename~ 已存在不会出错吗？

* function dictxxx
  几个针对 ~dict~ 的函数：
  #+BEGIN_SRC python
    def dictreverse(mapping):
        return dict([(value, key) for (key, value) in iteritems(mapping)])

    def dictfind(dictionary, element):
        for (key, value) in iteritems(dictionary):
            if element is value: 
                return key

    def dictfindall(dictionary, element):
        res = []
        for (key, value) in iteritems(dictionary):
            if element is value:
                res.append(key)
        return res

    def dictincr(dictionary, element):
        dictionary.setdefault(element, 0)
        dictionary[element] += 1
        return dictionary[element]

    def dictadd(*dicts):
        result = {}
        for dct in dicts:
            result.update(dct)
        return result
  #+END_SRC

  + dictreverse :: 第一遍没看清， 反转 ~dict~ ? ~dict~ 不是无序的么。。。

                   仔细一看才发现是反转键值对！

  + dictfind :: 返回特定值的键

  + dictfindall :: 刚想要是不止一个怎么说， 就来了个 ~findall~

  + dictincr :: ~d[e] = d.get(e, 0) + 1~

  + dictadd :: 更新多个字典， ~Python3~ 的 ~ChainMap~ 貌似有类似的功能

* function requeue
  #+BEGIN_SRC python
    def requeue(queue, index=-1):
        x = queue.pop(index)
        queue.insert(0, x)
        return x
  #+END_SRC

  将制定位置的元素取出放到队列首

* function restack
  #+BEGIN_SRC python
    def restack(stack, index=0):
        x = stack.pop(index)
        stack.append(x)
        return x
  #+END_SRC

  将制定元素取出放到栈尾

* function listget
  #+BEGIN_SRC python
    def listget(lst, ind, default=None):
        if len(lst)-1 < ind: 
            return default
        return lst[ind]
  #+END_SRC

  功能和 ~dict.get~ 有点像， 但是 ~ind < 0~ 怎么说 ？

  #+BEGIN_SRC python
    def listget(lst, ind, default=None):
        if (len(lst) - 1 < ind) or (-len(lst) > ind):
            return default
        return lst[ind]
  #+END_SRC

* function intget
  #+BEGIN_SRC python
    def intget(integer, default=None):
        try:
            return int(integer)
        except (TypeError, ValueError):
            return default
  #+END_SRC

  尝试将字符串 ~integer~ 转化为整型， 失败返回默认值。

  功能添加尝试：
  #+BEGIN_SRC python
    def intget(integer, base=10, default=None):
        try:
            return int(integer, base=base)
        except (TypeError, ValueError):
            return default
  #+END_SRC
  
* function numify
  将字符串中的非数字字符去除

  #+BEGIN_SRC python
    def numify(string):
        return ''.join([c for c in str(string) if c.isdigit()])
  #+END_SRC

  这个功能在 ~Python2~ 中通过 ~filter(str.isdigit, string)~ 可以很方便的实现， 但是到了 ~Python3~
  ~filter~ 返回的是一个迭代器， 还是需要 ~join~ 方法的使用。

* function denumify
  将字符串按照 ~pattern~ 的格式输出

  #+BEGIN_SRC python
    def denumify(string, pattern):
        out = []
        for c in pattern:
            if c == "X":
                out.append(string[0])
                string = string[1:]
            else:
                out.append(c)
        return ''.join(out)
  #+END_SRC

  ~pattern~ 中需要替换为 ~string~ 的字符用 ~X~ 标记

  使用迭代器：
  #+BEGIN_SRC python
    def denumify(string, pattern):
        istr, out = iter(string), list()
        for c in pattern:
            if c == 'X':
                out.append(next(istr))
            else:
                out.append(c)
        return ''.join(out)
  #+END_SRC

* function commify
  添加分隔符：
  #+BEGIN_SRC python
    def commify(n):
        if n is None: return None
        n = str(n).strip()

        if n.startswith('-'):
            prefix = '-'
            n = n[1:].strip()
        else:
            prefix = ''

        if '.' in n:
            dollars, cents = n.split('.')
        else:
            dollars, cents = n, None

        r = []
        for i, c in enumerate(str(dollars)[::-1]):
            if i and (not (i % 3)):
                r.insert(0, ',')
            r.insert(0, c)
        out = ''.join(r)
        if cents:
            out += '.' + cents
        return prefix + out
  #+END_SRC

  效果就是： ~commify(1234) ==> 1,234~
  

  简单实现类似的功能：
  #+BEGIN_SRC python
    def commify(n):
        if n in None:
            return None
        return '{0:,}'.format(n)
  #+END_SRC

  这样的实现相对简单， 但功能没那么强大。 不支持字符串新式的数字等

* function dateify
  时间格式化
  
  #+BEGIN_SRC python
    def dateify(datestring):
        return denumify(datestring, "XXXX-XX-XX XX:XX:XX")
  #+END_SRC

* function nthstr
  格式序号， 这个功能很不错

  #+BEGIN_SRC python
    def nthstr(n):
        assert n >= 0
        if n % 100 in [11, 12, 13]: return '%sth' % n
        return {1: '%sst', 2: '%snd', 3: '%srd'}.get(n % 10, '%sth') % n
  #+END_SRC

  最后这个 ~return~ 很强势

  效果：
  #+BEGIN_SRC python
    >>> [nthstr(x) for x in [2, 3, 4, 5, 10, 11, 12, 13, 14, 15]]
    ['2nd', '3rd', '4th', '5th', '10th', '11th', '12th', '13th', '14th', '15th']
  #+END_SRC

* function cond
  替换 ~if-else~
  #+BEGIN_SRC python
    def cond(predicate, consequence, alternative=None):
        """
        Function replacement for if-else to use in expressions.
            >>> x = 2
            >>> cond(x % 2 == 0, "even", "odd")
            'even'
            >>> cond(x % 2 == 0, "even", "odd") + '_row'
            'even_row'
        """
        if predicate:
            return consequence
        else:
            return alternative
  #+END_SRC

  感觉在 ~if-else~ 密集的地方使用应该不错

