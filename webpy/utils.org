#+TITLE:      utils
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#import][import]]
- [[#class-storage][class Storage]]
  - [[#function-storify][function storify]]
  - [[#function-safeunicode][function safeunicode]]
- [[#class-counter][class Counter]]
- [[#iters][iters]]
- [[#function-strips][function strips]]
- [[#function-timelimit][function timelimit]]
- [[#class-memoize][class Memoize]]
- [[#class-_re_subm_proxy][class _re_subm_proxy]]
  - [[#function-re_subm][function re_subm]]
- [[#function-group][function group]]
- [[#function-uniq][function uniq]]
- [[#function-iterview][function iterview]]

* import
  #+BEGIN_SRC python
    from __future__ import print_function

    __all__ = [...]

    import re, sys, time, threading, itertools, traceback, os

    import subprocess
    import datetime
    from threading import local as threadlocal

    from .py3helpers import PY2, itervalues, iteritems, text_type, string_types, imap, is_iter

    try:
        from StringIO import StringIO
    except ImportError:
        from io import StringIO
  #+END_SRC

  ~__all__~ 里面的东西是真滴多， 这个模块源码的阅读要点时间了......

  导入的模块里有几个不熟悉的：
  + itertools :: 用于高效循环的迭代函数集合， 简单的看了一下， 好东西， 了解一下
  + traceback :: 可以用于获取详细的异常信息
  + StringIO :: 在内存中读写 ~str~, 感觉好像可以用 /@_@/
  + threading & subprocess :: 貌似自己现在的程序用不上 /QAQ/

* class Storage
  这个类实现的功能是我一直想要的。
  #+BEGIN_SRC python
    class Storage(dict):
        def __getattr__(self, key):
            try:
                return self[key]
            except KeyError as k:
                raise AttributeError(k)

        def __setattr__(self, key, value): 
            self[key] = value

        def __delattr__(self, key):
            try:
                del self[key]
            except KeyError as k:
                raise AttributeError(k)

        def __repr__(self):
            return '<Storage ' + dict.__repr__(self) + '>'

    storage = Storage
  #+END_SRC

  实现还是很简单的， 可以这样操作字典了：
  #+BEGIN_SRC python
    >>> obj = storage(a = 1)
    >>> obj.a
    1
    >>> obj['a']
    1
    >>> obj.b = 10
    >>> obj.b
    10
  #+END_SRC

** function storify
   这个函数的作用是将一个映射对象转化为 ~storage~ 对象， 同时允许通过
   位置参数和关键字参数设置返回的 ~storage~ 对象的值。
   
   #+BEGIN_SRC python
     _unicode = defaults.pop('_unicode', False)

     # if _unicode is callable object, use it convert a string to unicode.
     to_unicode = safeunicode
     if _unicode is not False and hasattr(_unicode, "__call__"):
         to_unicode = _unicode
   #+END_SRC
   
   这段代码， 应该是和其他地方进行配合吧， 允许从映射中传入 ~to_unicode~ 的方法。
   
   对于 ~Python2~ 和 ~Python3~ 中 ~str~ 代表的字符串类型不同的解决方案， 默认使用 ~safeunicode~
   函数进行转换。 这个函数就定义在这个模块中： [[#function-safeunicode][safeunicode]]

   #+BEGIN_SRC python
     def unicodify(s):
         if _unicode and isinstance(s, str): return to_unicode(s)
         else: return s
   #+END_SRC

   依赖 ~to_unicode~, 定义了这个转换为 ~unicode~ 的函数， ~ify~ 后缀的意思是 ~使...变得...~

  #+BEGIN_SRC python
    def getvalue(x):
        if hasattr(x, 'file') and hasattr(x, 'value'):
            return x.value
        elif hasattr(x, 'value'):
            return unicodify(x.value)
        else:
            return unicodify(x)
  #+END_SRC

  保证程序内部的值的类型都是 ~unicode~, 只是， 什么对象具有 ~file~ 属性呢？

  #+BEGIN_SRC python
    def storify(mapping, *requireds, **defaults):
        ...
        for key in requireds + tuple(mapping.keys()):
            ...
        for (key, value) in iteritems(defaults):
            ...
  #+END_SRC

  这里是 ~storify~ 函数传入的参数列表， 分别使用了两个循环来处理后边的两个参数。
  循环内部大量使用 ~isinstance~ 函数， 在我看来不怎么有用的函数还是很有用的......

** function safeunicode   
   #+BEGIN_SRC python
     def safeunicode(obj, encoding='utf-8'):
         t = type(obj)
         if t is text_type:
             return obj
         elif t is bytes:
             return obj.decode(encoding)
         elif t in [int, float, bool]:
             return unicode(obj)
         else:
             return unicode(obj)

     def safestr(obj, encoding='utf-8'):
         if PY2 and isinstance(obj, unicode):
             return obj.encode(encoding)
         elif is_iter(obj):
             return imap(safestr, obj)
         else:
             return str(obj)

     if not PY2:
         safeunicode = safestr
   #+END_SRC

   这是实现 ~safeunicode~ 的源码， ~py3helpers~ 对类型的兼容处理在这里起到作用了。

   ~text_type~ 是 ~unicode~, 这里才发现可以像 ~t is text_type~ 这样判断类型。

   #+BEGIN_SRC python
     >>> type(dict)
     <type 'type'>
     >>> type(dict) is dict
     False
     >>> d = dict()
     >>> type(d)
     <type 'dict'>
     >>> type(d) is dict
     True
   #+END_SRC

   尝试了一下， ~type~ 返回对象的类型， ~dict~ 的类型是 ~type~, ~dict~ 实例的类型才是 ~dict~.

   ~safestr~ 函数这里晕了一下， 看了几遍， 意思应该就是对 ~Python2~ 和 ~Python3~ 的兼容了。

   将原有的对象安全的转换回 ~str~, 由于 ~Python2~ 和 ~Python3~ 中 ~str~ 的类型不相同， 所以需要绕一下。

   而 ~Python3~ 中， ~str~ 就是 ~unicode~, 所以 ~safeunicode = safestr~.

* class Counter
  这个类继承自 ~class storage~, 功能和 ~collections~ 模块的 ~Counter~ 有点类似， 但也有很多不同。

  实现的几个方法：

  #+BEGIN_SRC python
    # key 键值 + 1
    def add(self, n):
        self.setdefault(n, 0)
        self[n] += 1

    # 返回 value 最大的 key
    def most(self):
        m = max(itervalues(self))
        return [k for k, v in iteritems(self) if v == m]

    # 返回 value 最小的 key
    def least(self):
        m = min(self.itervalues())
        return [k for k, v in iteritems(self) if v == m]

    # 返回 key 的 value 在所有 values 中占得比例
    def percent(self, key):
        return float(self[key])/sum(self.values())

    # 返回排序的 keys
    def sorted_keys(self):
        return sorted(self.keys(), key=lambda k: self[k], reverse=True)

    # 返回排序的 values
    def sorted_values(self):
        return [self[k] for k in self.sorted_keys()]

    # 返回排序的 (key, value), 根据 key 排序
    def sorted_items(self):
        return [(k, self[k]) for k in self.sorted_keys()]
  #+END_SRC

  ~py3helpers~ 中对 ~dict~ 的 ~iter*~ 方法的处理真的很有用啊 ！

  #+BEGIN_SRC python
    counter = Counter
  #+END_SRC

* iters
  #+BEGIN_SRC python
    iters = [list, tuple, set, frozenset]
    class _hack(tuple): pass
    iters = _hack(iters)
    iters.__doc__ = """
    A list of iterable items (like lists, but not strings). Includes whichever
    of lists, tuples, sets, and Sets are available in this version of Python.
    """
  #+END_SRC

  第一眼， 为什么不直接就用 ~tuple~, 还要继承 ~tuple~, 然后才发现， ~__doc__~
  貌似是 *类变量*, 而且 ~tuple~ 的 ~__doc__~ 还是只读变量。

  还是继承好。

* function strips
  ~python str~ 对象自身就有 ~strip~ 方法， 经常用来去除不必要的空白字符。

  这里实现了一个高级的版本：
  #+BEGIN_SRC python
    def _strips(direction, text, remove):
        if isinstance(remove, iters):
            for subr in remove:
                text = _strips(direction, text, subr)
            return text

        if direction == 'l':
            if text.startswith(remove):
                return text[len(remove):]
        elif direction == 'r':
            if text.endswith(remove):
                return text[:-len(remove)]
        else:
            raise ValueError("Direction needs to be r or l.")
        return text
  #+END_SRC

  对于 ~for~ 循环那一段， ~Python~ 没有局部作用域是真滴强。

  后面的实现还是比较简单的。

  根据这个方法， 相继实现了：
  #+BEGIN_SRC python
    def lstrips(text, remove):
    def rstrips(text, remove):
    def strips(text, remove):
        return rstrips(lstrips(text, remove), remove)
  #+END_SRC

  最后的 ~strips~ 的实现感觉.

* function timelimit
  ~Python~ 之中， 一切皆是对象。 感觉这句话在这里有一些体现：
  #+BEGIN_SRC python
    def timelimit(timeout):
        def _1(function):
            def _2(*args, **kw):
                class Dispatch(threading.Thread):
                    def __init__(self):
                        threading.Thread.__init__(self)
                        self.result = None
                        self.error = None

                        self.setDaemon(True)
                        self.start()

                    def run(self):
                        try:
                            self.result = function(*args, **kw)
                        except:
                            self.error = sys.exc_info()

                c = Dispatch()
                c.join(timeout)
                if c.isAlive():
                    raise RuntimeError('took too long')
                if c.error:
                    raise c.error[1]
                return c.result
            return _2
        return _1
  #+END_SRC

  这个函数的使用流程：
  1. 定义一个函数 ~func~
  2. 通过 ~timelimit(timeout)~ 得到新的函数 ~func1~
  3. 通过 ~func1(func)~ 得到新的函数 ~func2~
  4. 使用 ~func2~
  
  简化的流程就是： ~timelimit(timeout)(func)()~.

  看到这一连串的括号， 嗯， 可以， 很强势。

  对于这个函数的作用， 我想我需要去了解一下 *多线程* 的内容先。

  了解了一下， 这个函数的代码看起来还是有点绕......

  首先， 最外层的 ~timelimit(timeout)~ 设置好超时时间， 获得 ~_1~. 然后通过 ~_1(function)~ 获得
   ~_2~. 在 ~_2~ 中， 继承 ~threading.Thread~ 的 ~class Dispatch~ 用来运行 ~function~. 最开始设置的
   超时时间用于判断 ~function~ 的执行是否在指定的时间内完成。

   嗯， 功能大概就是用来构建一个 *在指定之间内完成指定任务的函数*.

* class Memoize
  接着绕啊绕......

  首先， 是魔法方法 ~__call__~. 这个魔法方法允许向访问方法那样访问类的实例：
  #+BEGIN_SRC python
    class A(object):
        def __init__(self):
            self.num = 0

        def __call__(self, *args, **kwargs):
            self.num += 1
            return self.num

    num = A()
    print(num())
    print(num())
    print(num())
  #+END_SRC

  然后， 是这个类来干嘛的 ！
  #+BEGIN_SRC python
    class Memoize:
        def __init__(self, func, expires=None, background=True):
            self.func = func
            self.cache = {}
            self.expires = expires
            self.background = background
            self.running = {}

        def __call__(self, *args, **keywords):
            key = (args, tuple(keywords.items()))
            if not self.running.get(key):
                self.running[key] = threading.Lock()
            def update(block=False):
                if self.running[key].acquire(block):
                    try:
                        self.cache[key] = (self.func(*args, **keywords), time.time())
                    finally:
                        self.running[key].release()

            if key not in self.cache:
                update(block=True)
            elif self.expires and (time.time() - self.cache[key][1]) > self.expires:
                if self.background:
                    threading.Thread(target=update).start()
                else:
                    update()
            return self.cache[key][0]
  #+END_SRC

  这个类会保存每次运算的结果， 根据调用方法的参数。

  保存运算结果时会一同保存得到结果的时间， 如果调用时定义了 ~expires~, 会根据调用的时间和上一次得到
  的结果差来判断是否需要更新结果。

  如果定义了 ~background=True~, 会将计算结果的过程放入一个单独的线程进行。

  对于 ~update~ 中的线程锁， 继续补充知识 !

  看了一下， 完全理解还是有一定难度， 但粗略的理解还是可以了。

  ~cache~ 的更新依赖于 ~running~ 中的键， ~running~ 中的每一个键都是一个锁对象。 通过 ~running~
  每个键的锁对象来实现对 ~cache~ 中的数据的保护。

  #+BEGIN_SRC python 
    memoize = Memoize

    re_compile = memoize(re.compile) #@@ threadsafe?
    re_compile.__doc__ = """
    A memoized version of re.compile.
    """
  #+END_SRC
  
  保存每次 ~re.compile~ 的结果。

* class _re_subm_proxy
  #+BEGIN_SRC python
    class _re_subm_proxy:
        def __init__(self): 
            self.match = None
        def __call__(self, match): 
            self.match = match
            return ''
  #+END_SRC
  很明显， 这个类是服务于后面的内容的。

** function re_subm
   #+BEGIN_SRC python
     def re_subm(pat, repl, string):
         compiled_pat = re_compile(pat)
         proxy = _re_subm_proxy()
         compiled_pat.sub(proxy.__call__, string)
         return compiled_pat.sub(repl, string), proxy.match
   #+END_SRC

   这段代码让我最疑惑的是： ~compiled_pat.sub(proxy.__call__, string)~. 容易明白的是， ~compiled_pat~
   应该是一个 ~compile~ 对象， 可是 ~sub~ 的第一个参数是什么鬼 ？

   看了一下文档， ~sub~ 的第一个方法除了可以是字符串以外， 还可以是一个方法， 这个方法只能接受
   一个参数 ~match~.

* function group
  函数功能： 序列分组
  #+BEGIN_SRC python
    def group(seq, size): 
        def take(seq, n):
            for i in range(n):
                yield next(seq)

        if not hasattr(seq, 'next'):  
            seq = iter(seq)
        while True: 
            x = list(take(seq, size))
            if x:
                yield x
            else:
                break
  #+END_SRC
  根据指定的 ~size~ 将序列 ~seq~ 分组。

  对于 ~hasattr(seq, 'next')~ 这一段， 之前在 ~py3helpers~ 中都对 ~next~ 和 ~__next__~ 进行了区分， 这里没有。
  虽然感觉有些有些奇怪， 但是这一点貌似没有影响。 我觉得干脆直接改成 ~iter(seq)~ 应该也不会出错。

  另外， ~iter~ 和 ~next~ 的一种用法还是很有启示的。

* function uniq
  函数作用： 去重
  #+BEGIN_SRC python
    def uniq(seq, key=None):
        key = key or (lambda x: x)
        seen = set()
        result = []
        for v in seq:
            k = key(v)
            if k in seen:
                continue
            seen.add(k)
            result.append(v)
        return result
  #+END_SRC

  第一行： ~key = key or (lambda x: x)~. 还可以这样的吗 ？

  尝试：
  #+BEGIN_SRC python
    >>> x = 10
    >>> x = x or 1
    >>> x
    10
    >>> x = None
    >>> x = x or 1
    >>> x
    1
    >>> x = None or None or 1
    >>> x
    1
  #+END_SRC

  找到文档了： [[https://docs.python.org/2.7/reference/expressions.html#boolean-operations][Boolean operations]]

  不愧是我大 ~Python~.

  后面的代码虽然第一眼感觉可以简化， 毕竟去重很快。 仔细一看， 还保留了原始序列的顺序！ 高级

* function iterview 
  #+BEGIN_SRC python
    def iterview(x):
       """
       Takes an iterable `x` and returns an iterator over it
       which prints its progress to stderr as it iterates through.
       """
       WIDTH = 70

       def plainformat(n, lenx):
           return '%5.1f%% (%*d/%d)' % ((float(n)/lenx)*100, len(str(lenx)), n, lenx)

       def bars(size, n, lenx):
           val = int((float(n)*size)/lenx + 0.5)
           if size - val:
               spacing = ">" + (" "*(size-val))[1:]
           else:
               spacing = ""
           return "[%s%s]" % ("="*val, spacing)

       def eta(elapsed, n, lenx):
           if n == 0:
               return '--:--:--'
           if n == lenx:
               secs = int(elapsed)
           else:
               secs = int((elapsed/n) * (lenx-n))
           mins, secs = divmod(secs, 60)
           hrs, mins = divmod(mins, 60)

           return '%02d:%02d:%02d' % (hrs, mins, secs)

       def format(starttime, n, lenx):
           out = plainformat(n, lenx) + ' '
           if n == lenx:
               end = '     '
           else:
               end = ' ETA '
           end += eta(time.time() - starttime, n, lenx)
           out += bars(WIDTH - len(out) - len(end), n, lenx)
           out += end
           return out

       starttime = time.time()
       lenx = len(x)
       for n, y in enumerate(x):
           sys.stderr.write('\r' + format(starttime, n, lenx))
           yield y
       sys.stderr.write('\r' + format(starttime, n+1, lenx) + '\n')
  #+END_SRC

  这个函数的作用很明确， 输出效果很 ~nice~.
