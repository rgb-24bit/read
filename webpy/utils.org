#+TITLE:      utils
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#import][import]]
- [[#class-storage][class Storage]]
  - [[#function-storify][function storify]]
  - [[#function-safeunicode][function safeunicode]]
- [[#class-counter][class Counter]]
- [[#iters][iters]]
- [[#function-strips][function strips]]
- [[#function-timelimit][function timelimit]]

* import
  #+BEGIN_SRC python
    from __future__ import print_function

    __all__ = [...]

    import re, sys, time, threading, itertools, traceback, os

    import subprocess
    import datetime
    from threading import local as threadlocal

    from .py3helpers import PY2, itervalues, iteritems, text_type, string_types, imap, is_iter

    try:
        from StringIO import StringIO
    except ImportError:
        from io import StringIO
  #+END_SRC

  ~__all__~ 里面的东西是真滴多， 这个模块源码的阅读要点时间了......

  导入的模块里有几个不熟悉的：
  + itertools :: 用于高效循环的迭代函数集合， 简单的看了一下， 好东西， 了解一下
  + traceback :: 可以用于获取详细的异常信息
  + StringIO :: 在内存中读写 ~str~, 感觉好像可以用 /@_@/
  + threading & subprocess :: 貌似自己现在的程序用不上 /QAQ/

* class Storage
  这个类实现的功能是我一直想要的。
  #+BEGIN_SRC python
    class Storage(dict):
        def __getattr__(self, key):
            try:
                return self[key]
            except KeyError as k:
                raise AttributeError(k)

        def __setattr__(self, key, value): 
            self[key] = value

        def __delattr__(self, key):
            try:
                del self[key]
            except KeyError as k:
                raise AttributeError(k)

        def __repr__(self):
            return '<Storage ' + dict.__repr__(self) + '>'

    storage = Storage
  #+END_SRC

  实现还是很简单的， 可以这样操作字典了：
  #+BEGIN_SRC python
    >>> obj = storage(a = 1)
    >>> obj.a
    1
    >>> obj['a']
    1
    >>> obj.b = 10
    >>> obj.b
    10
  #+END_SRC

** function storify
   这个函数的作用是将一个映射对象转化为 ~storage~ 对象， 同时允许通过
   位置参数和关键字参数设置返回的 ~storage~ 对象的值。
   
   #+BEGIN_SRC python
     _unicode = defaults.pop('_unicode', False)

     # if _unicode is callable object, use it convert a string to unicode.
     to_unicode = safeunicode
     if _unicode is not False and hasattr(_unicode, "__call__"):
         to_unicode = _unicode
   #+END_SRC
   
   这段代码， 应该是和其他地方进行配合吧， 允许从映射中传入 ~to_unicode~ 的方法。
   
   对于 ~Python2~ 和 ~Python3~ 中 ~str~ 代表的字符串类型不同的解决方案， 默认使用 ~safeunicode~
   函数进行转换。 这个函数就定义在这个模块中： [[#function-safeunicode][safeunicode]]

   #+BEGIN_SRC python
     def unicodify(s):
         if _unicode and isinstance(s, str): return to_unicode(s)
         else: return s
   #+END_SRC

   依赖 ~to_unicode~, 定义了这个转换为 ~unicode~ 的函数， ~ify~ 后缀的意思是 ~使...变得...~

  #+BEGIN_SRC python
    def getvalue(x):
        if hasattr(x, 'file') and hasattr(x, 'value'):
            return x.value
        elif hasattr(x, 'value'):
            return unicodify(x.value)
        else:
            return unicodify(x)
  #+END_SRC

  保证程序内部的值的类型都是 ~unicode~, 只是， 什么对象具有 ~file~ 属性呢？

  #+BEGIN_SRC python
    def storify(mapping, *requireds, **defaults):
        ...
        for key in requireds + tuple(mapping.keys()):
            ...
        for (key, value) in iteritems(defaults):
            ...
  #+END_SRC

  这里是 ~storify~ 函数传入的参数列表， 分别使用了两个循环来处理后边的两个参数。
  循环内部大量使用 ~isinstance~ 函数， 在我看来不怎么有用的函数还是很有用的......

** function safeunicode   
   #+BEGIN_SRC python
     def safeunicode(obj, encoding='utf-8'):
         t = type(obj)
         if t is text_type:
             return obj
         elif t is bytes:
             return obj.decode(encoding)
         elif t in [int, float, bool]:
             return unicode(obj)
         else:
             return unicode(obj)

     def safestr(obj, encoding='utf-8'):
         if PY2 and isinstance(obj, unicode):
             return obj.encode(encoding)
         elif is_iter(obj):
             return imap(safestr, obj)
         else:
             return str(obj)

     if not PY2:
         safeunicode = safestr
   #+END_SRC

   这是实现 ~safeunicode~ 的源码， ~py3helpers~ 对类型的兼容处理在这里起到作用了。

   ~text_type~ 是 ~unicode~, 这里才发现可以像 ~t is text_type~ 这样判断类型。

   #+BEGIN_SRC python
     >>> type(dict)
     <type 'type'>
     >>> type(dict) is dict
     False
     >>> d = dict()
     >>> type(d)
     <type 'dict'>
     >>> type(d) is dict
     True
   #+END_SRC

   尝试了一下， ~type~ 返回对象的类型， ~dict~ 的类型是 ~type~, ~dict~ 实例的类型才是 ~dict~.

   ~safestr~ 函数这里晕了一下， 看了几遍， 意思应该就是对 ~Python2~ 和 ~Python3~ 的兼容了。

   将原有的对象安全的转换回 ~str~, 由于 ~Python2~ 和 ~Python3~ 中 ~str~ 的类型不相同， 所以需要绕一下。

   而 ~Python3~ 中， ~str~ 就是 ~unicode~, 所以 ~safeunicode = safestr~.

* class Counter
  这个类继承自 ~class storage~, 功能和 ~collections~ 模块的 ~Counter~ 有点类似， 但也有很多不同。

  实现的几个方法：

  #+BEGIN_SRC python
    # key 键值 + 1
    def add(self, n):
        self.setdefault(n, 0)
        self[n] += 1

    # 返回 value 最大的 key
    def most(self):
        m = max(itervalues(self))
        return [k for k, v in iteritems(self) if v == m]

    # 返回 value 最小的 key
    def least(self):
        m = min(self.itervalues())
        return [k for k, v in iteritems(self) if v == m]

    # 返回 key 的 value 在所有 values 中占得比例
    def percent(self, key):
        return float(self[key])/sum(self.values())

    # 返回排序的 keys
    def sorted_keys(self):
        return sorted(self.keys(), key=lambda k: self[k], reverse=True)

    # 返回排序的 values
    def sorted_values(self):
        return [self[k] for k in self.sorted_keys()]

    # 返回排序的 (key, value), 根据 key 排序
    def sorted_items(self):
        return [(k, self[k]) for k in self.sorted_keys()]
  #+END_SRC

  ~py3helpers~ 中对 ~dict~ 的 ~iter*~ 方法的处理真的很有用啊 ！

  #+BEGIN_SRC python
    counter = Counter
  #+END_SRC

* iters
  #+BEGIN_SRC python
    iters = [list, tuple, set, frozenset]
    class _hack(tuple): pass
    iters = _hack(iters)
    iters.__doc__ = """
    A list of iterable items (like lists, but not strings). Includes whichever
    of lists, tuples, sets, and Sets are available in this version of Python.
    """
  #+END_SRC

  第一眼， 为什么不直接就用 ~tuple~, 还要继承 ~tuple~, 然后才发现， ~__doc__~
  貌似是 *类变量*, 而且 ~tuple~ 的 ~__doc__~ 还是只读变量。

  还是继承好。

* function strips
  ~python str~ 对象自身就有 ~strip~ 方法， 经常用来去除不必要的空白字符。

  这里实现了一个高级的版本：
  #+BEGIN_SRC python
    def _strips(direction, text, remove):
        if isinstance(remove, iters):
            for subr in remove:
                text = _strips(direction, text, subr)
            return text

        if direction == 'l':
            if text.startswith(remove):
                return text[len(remove):]
        elif direction == 'r':
            if text.endswith(remove):
                return text[:-len(remove)]
        else:
            raise ValueError("Direction needs to be r or l.")
        return text
  #+END_SRC

  对于 ~for~ 循环那一段， ~Python~ 没有局部作用域是真滴强。

  后面的实现还是比较简单的。

  根据这个方法， 相继实现了：
  #+BEGIN_SRC python
    def lstrips(text, remove):
    def rstrips(text, remove):
    def strips(text, remove):
        return rstrips(lstrips(text, remove), remove)
  #+END_SRC

  最后的 ~strips~ 的实现感觉.

* function timelimit
  ~Python~ 之中， 一切皆是对象。 感觉这句话在这里有一些体现：
  #+BEGIN_SRC python
    def timelimit(timeout):
        def _1(function):
            def _2(*args, **kw):
                class Dispatch(threading.Thread):
                    def __init__(self):
                        threading.Thread.__init__(self)
                        self.result = None
                        self.error = None

                        self.setDaemon(True)
                        self.start()

                    def run(self):
                        try:
                            self.result = function(*args, **kw)
                        except:
                            self.error = sys.exc_info()

                c = Dispatch()
                c.join(timeout)
                if c.isAlive():
                    raise RuntimeError('took too long')
                if c.error:
                    raise c.error[1]
                return c.result
            return _2
        return _1
  #+END_SRC

  这个函数的使用流程：
  1. 定义一个函数 ~func~
  2. 通过 ~timelimit(timeout)~ 得到新的函数 ~func1~
  3. 通过 ~func1(func)~ 得到新的函数 ~func2~
  4. 使用 ~func2~
  
  简化的流程就是： ~timelimit(timeout)(func)()~.

  看到这一连串的括号， 嗯， 可以， 很强势。

  对于这个函数的作用， 我想我需要去了解一下 *多线程* 的内容先。

