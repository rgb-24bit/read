#+TITLE:      requests v0.2.1 源码阅读
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* 目录                                                    :TOC_4_gh:noexport:
- [[#版本对比][版本对比]]
- [[#corepy][core.py]]
- [[#encodepy][encode.py]]
  - [[#魔法方法-__cmp__][魔法方法 ~__cmp__~]]
  - [[#classmethod][@classmethod]]
  - [[#魔法方法-__iter__][魔法方法 ~__iter__~]]
- [[#streaminghttppy][streaminghttp.py]]
  - [[#还可以这样-][还可以这样 ?]]
  - [[#作用域问题][作用域问题]]
- [[#收获][收获]]

* 版本对比
  通过 ~git diff v0.2.0:requests/core.py v0.2.1:requests/core.py~ 和 ~HISTORY.rst~
  可以发现, 两个版本之间的主要变化集中在对 ~PUT~ 和 ~POST~ 方法的处理上.

  应该是为了对编码方式进行处理, 添加了两个模块: ~encode.py~ 和 ~streaminghttp.py~.

  emmm, ~HISTORY.rst~ 上 ~0.2.0~ 和 ~0.2.1~ 的时间都是 ~2011-02-14~...

  添加的属性应该是 ~Response.url~ 吧...

* core.py
  还是现成 ~core.py~ 开始.

  添加功能的部分没事么好说的, 不过有一个变化很有趣:
  #+BEGIN_EXAMPLE
                def __repr__(self):
    -               try:
    -                       repr = '<Request [%s]>' % (self.method)
    -               except:
    -                       repr = '<Request object>'
    -               return repr
    +               return '<Request [%s]>' % (self.method)
  #+END_EXAMPLE

  对 ~__repr__~ 方法的处理, 去掉的 ~try..except..~, 改成了直接的: ~'<Request [%s]>' % (self.method)~.

  我试了一下, 如果 ~%s~ 对应的元素为 ~None~ 的话, 并不会报错, 而是返回 ~'None'~.

  应该是这个原因修改的吧...

* encode.py
  ~core.py~ 的变化不多, 功能的添加主要是通过新建的模块来实现的.
  
  模块开始, 是一些列的 ~import~. 作者对 ~import~ 作了兼容性的处理:
  #+BEGIN_SRC python
    try:
        from email.header import Header
    except ImportError:
        # Python 2.4
        from email.Header import Header
  #+END_SRC
  说起了, 自己写的代码还没做过这方面的工作...

  之后, 便是函数的编写了.
  
  有点在意的是编码格式的判断...
  #+BEGIN_SRC python
    if isinstance(s, unicode):
        return s.encode("utf-8")
  #+END_SRC
  emmm, 看来看书没细心...
  
  还有便是 ~raise~, 其实上一个版本也出现了...
  
  当初看书的时候 ~raise~ 的内容和 ~try...except...~ 连在一起的, 搞得现在下意识认为 ~raise~
  必须和 ~try...except...~ 一起用了...

** 魔法方法 ~__cmp__~ 
   又是一个没用过的魔法方法, 第一次出现是在 ~class MultipartParam~.
   #+BEGIN_SRC python
     def __cmp__(self, other):
         attrs = ['name', 'value', 'filename', 'filetype', 'filesize', 'fileobj']
         myattrs = [getattr(self, a) for a in attrs]
         oattrs = [getattr(other, a) for a in attrs]
         return cmp(myattrs, oattrs)
   #+END_SRC
   emmm...

** @classmethod
   与之相关的还有: ~@staticmethod~. 通过这两个装饰器装饰的方法, 可以直接通过: ~类名.方法名~ 调用.
   之前一直在思考怎么可以这样做...

   两者的区别:
   + ~@staticmethod~ 不需要表示自身对象的 ~self~ 和自身类的 ~cls~ 参数, 就跟使用函数一样
   + ~@classmethod~ 也不需要 ~self~ 参数, 但第一个参数需要是表示自身类的 ~cls~ 参数

   #+BEGIN_SRC python
     @staticmethod
     def fun(arg):
         pass

     @classmethod
     def fun(cls, arg):
         pass
   #+END_SRC
  
   ~@classmethod~ 因为带有 ~cls~ 参数, 因此可以调用类的属性, 方法和实例化对象等.
   
   比如返回类的实例:
   #+BEGIN_SRC python
     @classmethod
     def from_file(cls, paramname, filename):
         """Returns a new MultipartParam object constructed from the local
         file at ``filename``.

         ``filesize`` is determined by os.path.getsize(``filename``)

         ``filetype`` is determined by mimetypes.guess_type(``filename``)[0]

         ``filename`` is set to os.path.basename(``filename``)
         """

         return cls(paramname, filename=os.path.basename(filename),
                 filetype=mimetypes.guess_type(filename)[0],
                 filesize=os.path.getsize(filename),
                 fileobj=open(filename, "rb"))
   #+END_SRC

** 魔法方法 ~__iter__~
   ~__iter__~ 返回一个迭代器(具有 ~next~ 方法的对象).

   #+BEGIN_SRC python
     class multipart_yielder:
         def __init__(self, params, boundary, cb):
             ...

         def __iter__(self):
             return self

         def next(self):
             ...
   #+END_SRC
   
* streaminghttp.py
  ~__all__~ 不断出现在我眼前...

  说起了我都用过这个东西了...

  但是还不知道具体作用....

  ~__all__~, 是一个 ~string~ 元素组成的 ~list~ 变量, 
  定义了当你使用 ~from <module> import *~ 导入某个模块的时候能导出的符号.

  ~__all__~ 只影响到了 ~from <module> import *~ 这种导入方式,
  对于 ~from <module> import <member>~ 导入方式并没有影响, 仍然可以从外部导入
  
** 还可以这样 ?
   #+BEGIN_SRC python
     if hasattr(httplib, 'HTTPS'):
         class StreamingHTTPSConnection(_StreamingHTTPMixin,
                 httplib.HTTPSConnection):
             """Subclass of `httplib.HTTSConnection` that overrides the `send()`
             method to support iterable body objects"""

         class StreamingHTTPSHandler(urllib2.HTTPSHandler):
             """Subclass of `urllib2.HTTPSHandler` that uses
             StreamingHTTPSConnection as its http connection class."""

             handler_order = urllib2.HTTPSHandler.handler_order - 1

             def https_open(self, req):
                 return self.do_open(StreamingHTTPSConnection, req)

             def https_request(self, req):
                 # Make sure that if we're using an iterable object as the request
                 # body, that we've also specified Content-Length
                 if req.has_data():
                     data = req.get_data()
                     if hasattr(data, 'read') or hasattr(data, 'next'):
                         if not req.has_header('Content-length'):
                             raise ValueError(
                                     "No Content-Length specified for iterable body")
                 return urllib2.HTTPSHandler.do_request_(self, req)
   #+END_SRC

** 作用域问题
   没的说, 上面的问题绝对是作用域的问题.

   参考链接: [[http://python.jobbole.com/86465/][Python 五个知识点搞定作用域]].

   所以说, ~Python~ 没有块级作用域, 也就是: ~if/elif/else/ try/except for/while~ 内定义
   的变量, 外部也是可以访问的...

   当然, ~def/class/lambda~ 不可以...

   哎呀, 安逸....

* 收获
  最大的收获的话, 就是 ~@classmethod~ 和 ~@staticmethod~ 装饰器, 以及作用域问题了.

