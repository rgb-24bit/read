#+TITLE:      py3helpers
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* 模块作用
  #+BEGIN_EXAMPLE
    Utilities for make the code run both on Python2 and Python3.
  #+END_EXAMPLE
  
  尽管 ~Python2~ 快要停止维护了， 但是目前来说， ~Python3~ 和 ~Python2~ 的兼容还是有一定
  必要的。

* 兼容实现
  + sys.version_info :: Version information as a named tuple

       #+BEGIN_SRC python
         >>> import sys
         >>> sys.version_info
         sys.version_info(major=2, minor=7, micro=13, releaselevel='final', serial=0)
       #+END_SRC

       可以看到， 这个元组的第一个元素就是当前解释器的主要版本， 获取这个版本， 可以
       很方便的根据不同的版本处理不同的特性， 而不只是通过 ~try...except...~ 来操作。

  + urljoin :: ~Py2~ 和 ~Py3~ 的 ~urllib~ 库不兼容， 解决方式：
               #+BEGIN_SRC python
                 if PY2:
                     from urlparse import urljoin
                 else:
                     from urllib.parse import urljoin
               #+END_SRC

               这个库的不兼容是真的*痛。

  + 字典的迭代 :: ~lambda~ 上场：
             #+BEGIN_SRC python
               if PY2:
                   iterkeys = lambda d: d.iterkeys()
                   itervalues = lambda d: d.itervalues()
                   iteritems = lambda d: d.iteritems()
               else:
                   iterkeys = lambda d: iter(d.keys())
                   itervalues = lambda d: iter(d.values())
                   iteritems = lambda d: iter(d.items())
             #+END_SRC

  + 类型 :: ~unicdoe~ 和 ~int~:
          #+BEGIN_SRC python
            if PY2:
                text_type = unicode
                string_types = (str, unicode)
                numeric_types = (int, long)
            else:
                text_type = str
                string_types = (str,)
                numeric_types = (int,)
          #+END_SRC

          ~Python2~ 和 ~Python3~ 的 ~str~ 的类型是不同的， 同时整数就只有 ~int~ 型了

  + 可迭代对象判断 :: ~Python2~ -- ~next~, ~Python3~ -- ~__next__~
               #+BEGIN_SRC python
                 if PY2:
                     is_iter = lambda x: x and hasattr(x, 'next')
                 else:
                     is_iter = lambda x: x and hasattr(x, '__next__')
               #+END_SRC

  + map :: 原来 ~Python2~ 也有返回迭代器的 ~map~:
           #+BEGIN_SRC python
             if PY2:
                 from itertools import imap
             else:
                 imap = map
           #+END_SRC

  所以说， 如果 ~Python2~ 和 ~Python3~ 是兼容的就好了......

