#+TITLE:      threading
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#target][Target]]
- [[#class-_localimpl][class _localimpl]]
- [[#function-_patch][function _patch]]
- [[#class-local][class local]]
- [[#总结][总结]]
- [[#相关链接][相关链接]]

* Target
  不可能阅读整个 ~threading~ 模块的源码的，这次来阅读 ~threading~ 源码的主要目的就是了解 ~threading.local~ 的实现。

  而 ~threading.local~ 的实现代码也不多，两个类加一个函数，应该能够一次性完成。

* class _localimpl
  #+BEGIN_SRC python
    class _localimpl:
        """A class managing thread-local dicts"""
        __slots__ = 'key', 'dicts', 'localargs', 'locallock', '__weakref__'

        def __init__(self):
            # The key used in the Thread objects' attribute dicts.
            # We keep it a string for speed but make it unlikely to clash with
            # a "real" attribute.
            self.key = '_threading_local._localimpl.' + str(id(self))
            # { id(Thread) -> (ref(Thread), thread-local dict) }
            self.dicts = {}

        def get_dict(self):
            """Return the dict for the current thread. Raises KeyError if none
            defined."""
            thread = current_thread()
            return self.dicts[id(thread)][1]

        def create_dict(self):
            """Create a new dict for the current thread, and return it."""
            localdict = {}
            key = self.key
            thread = current_thread()
            idt = id(thread)
            def local_deleted(_, key=key):
                # When the localimpl is deleted, remove the thread attribute.
                thread = wrthread()
                if thread is not None:
                    del thread.__dict__[key]
            def thread_deleted(_, idt=idt):
                # When the thread is deleted, remove the local dict.
                # Note that this is suboptimal if the thread object gets
                # caught in a reference loop. We would like to be called
                # as soon as the OS-level thread ends instead.
                local = wrlocal()
                if local is not None:
                    dct = local.dicts.pop(idt)
            wrlocal = ref(self, local_deleted)
            wrthread = ref(thread, thread_deleted)
            thread.__dict__[key] = wrlocal
            self.dicts[idt] = wrthread, localdict
            return localdict
  #+END_SRC

  这个类的实现中有点绕的是 ~create_dict~, 我觉得要理一下：
  1. 首先是几个变量：
     |-----------+--------------------------------|
     | 变量      | 含义                           |
     |-----------+--------------------------------|
     | ~localdict~ | 创建的线程局部变量的字典       |
     | ~key~       | 表示当前 ~_localimpl~ 对象的 ~key~ |
     | ~thread~    | 当前的线程对象                 |
     | ~idt~       | 当前线程对象的 ~id~              |
     | ~wrlocal~   | 当前 ~_localimpl~ 对象的弱引用   |
     | ~wrthread~  | 当前线程对象的弱引用           |
     |-----------+--------------------------------|

  2. 函数 ~local_deleted~ 在当前的 ~_localimpl~ 对象被销毁时调用。

     通过 ~wrthread()~ 获取当前线程对象的强引用，如果该线程对象依然存活，
     就删除这个线程的 ~_localimpl~ 对象.

  3. 函数 ~thread_deleted~ 在线程销毁时调用，删除 ~_localimpl~ 对象中的这个线程的 ~localdict~.

  emmmm, ~_localimpl~ 对象的 ~dicts~ 中通过线程 ~id~ 保存了线程的弱引用和线程的 ~localdict~.

  线程对象的 ~__dict__~ 中通过 ~_localimpl~ 对象的 ~key~ 保存了 ~_localimpl~ 的弱引用。

  还是绕......

* function _patch
  #+BEGIN_SRC python
    @contextmanager
    def _patch(self):
        impl = object.__getattribute__(self, '_local__impl')
        try:
            dct = impl.get_dict()
        except KeyError:
            dct = impl.create_dict()
            args, kw = impl.localargs
            self.__init__(*args, **kw)
        with impl.locallock:
            object.__setattr__(self, '__dict__', dct)
            yield
  #+END_SRC
  
  这个补丁给人的感觉有点诡异......

  妙啊！！！

  ~_localimpl~ 对象的方法 ~get_dict~ 是获取当前线程的 ~localdict~, 如果不存在，说明当前线程还没有
  创建 ~localdict~, 然后就给它创建一个。

  然后， ~object.__setattr__(self, '__dict__', dct)~ 把当前的 ~local~ 对象的 ~__dict__~ 替换为
  该线程的 ~localdict~.

  在获取设置删除 ~local~ 对象的属性时都会调用这个 ~_patch~.

  也就是说，通过 ~local~ 对象操作的属性必然是在该线程的 ~localdict~ 中的。

  还贴心的用了语句 ~__self.__init__(*args, **kw)~ 方便我们继承 ~local~.

  nice(破音).

* class local
  #+BEGIN_SRC python
    class local:
        __slots__ = '_local__impl', '__dict__'

        def __new__(cls, *args, **kw):
            if (args or kw) and (cls.__init__ is object.__init__):
                raise TypeError("Initialization arguments are not supported")
            self = object.__new__(cls)
            impl = _localimpl()
            impl.localargs = (args, kw)
            impl.locallock = RLock()
            object.__setattr__(self, '_local__impl', impl)
            # We need to create the thread dict in anticipation of
            # __init__ being called, to make sure we don't call it
            # again ourselves.
            impl.create_dict()
            return self

        def __getattribute__(self, name):
            with _patch(self):
                return object.__getattribute__(self, name)

        def __setattr__(self, name, value):
            if name == '__dict__':
                raise AttributeError(
                    "%r object attribute '__dict__' is read-only"
                    % self.__class__.__name__)
            with _patch(self):
                return object.__setattr__(self, name, value)

        def __delattr__(self, name):
            if name == '__dict__':
                raise AttributeError(
                    "%r object attribute '__dict__' is read-only"
                    % self.__class__.__name__)
            with _patch(self):
                return object.__delattr__(self, name)
  #+END_SRC

  看完前面两个，在看这个，就很简单了。

* 总结  
  目前来说， ~thread.local~ 的实现中，最让我迷惑的就是 ~_localimpl.create_dict~ 了，主要是
  涉及到弱引用的使用，这方面还不是很熟悉。

  但也大致明白了 ~local~ 对象的工作原理， ~_patch~ 真是神来之笔。

  目前比较好奇的是其他语言中的实现方式。

* 相关链接
  + [[https://github.com/python/cpython/blob/master/Lib/_threading_local.py][_threading_local.py]]
