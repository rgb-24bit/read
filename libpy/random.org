#+TITLE:      random
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#简介][简介]]
- [[#常量][常量]]
- [[#_randomrandom][_random.Random]]
- [[#random][Random]]
  - [[#randrange][randrange]]
  - [[#choice][choice]]
  - [[#shuffle][shuffle]]
  - [[#sample][sample]]
  - [[#choices][choices]]
- [[#相关链接][相关链接]]

* 简介
  *Python* 的 *random* 模块对 *随机操作* 的支持应该是我见过的最丰富的一个模块了。

  这里来了解一下部分操作是如何实现的。

* 常量
  #+BEGIN_SRC python
    from math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil
    from math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin

    NV_MAGICCONST = 4 * _exp(-0.5)/_sqrt(2.0)
    TWOPI = 2.0*_pi
    LOG4 = _log(4.0)
    SG_MAGICCONST = 1.0 + _log(4.5)
    BPF = 53        # Number of bits in a float
    RECIP_BPF = 2**-BPF
  #+END_SRC

  这个看看就好， 反正也看不懂。

* _random.Random
  *Random* 类继承了 *_random.Random* 这个类，看了一下，感觉挺有趣的。

  #+BEGIN_SRC python
    >>> import _random
    >>> help(_random)
    Help on built-in module _random:

    NAME
        _random - Module implements the Mersenne Twister random number generator.

    CLASSES
        builtins.object
            Random

        class Random(builtins.object)
         |  Random() -> create a random number generator with its own internal state.
         |
         |  Methods defined here:
         |
         |  __getattribute__(self, name, /)
         |      Return getattr(self, name).
         |
         |  __new__(*args, **kwargs) from builtins.type
         |      Create and return a new object.  See help(type) for accurate signature.
         |
         |  getrandbits(...)
         |      getrandbits(k) -> x.  Generates an int with k random bits.
         |
         |  getstate(...)
         |      getstate() -> tuple containing the current state.
         |
         |  random(...)
         |      random() -> x in the interval [0, 1).
         |
         |  seed(...)
         |      seed([n]) -> None.  Defaults to current time.
         |
         |  setstate(...)
         |      setstate(state) -> None.  Restores generator state.

    FILE
        (built-in)
  #+END_SRC

  最有趣的方法应该是 *getrandbits* 了，获取指定 *位数* 的随机数，如果指定 *1* 位，那么生成的随机数就只有 *0* 或 *1*.

  #+BEGIN_SRC python
    >>> random.getrandbits(1)
    0
    >>> random.getrandbits(1)
    0
    >>> random.getrandbits(1)
    0
    >>> random.getrandbits(1)
    1
  #+END_SRC

  实现感觉和 [[https://github.com/python/cpython/blob/3.6/Modules/_randommodule.c][_randommodule.c]] 有关， *getrandbits* 的部分代码：
  #+BEGIN_SRC C
    if (k <= 32)  /* Fast path */
      return PyLong_FromUnsignedLong(genrand_int32(self) >> (32 - k));
  #+END_SRC

  简单来说，生成一个 *32* 位的随机数， 然后右移去除高位。

* Random
  这应该是我们使用 *random* 这个模块时用的最多的类了。

  *random* 覆盖了父类的几个方法， 在 *seed* 中， 这行代码很强势：
  #+BEGIN_SRC python
    a = a.decode('latin-1') if isinstance(a, bytes) else a
  #+END_SRC

  *latin-1* 简直就是万用编码， 单字节真爽！

  *Random* 对象还支持 *pickle*, 虽然感觉没啥用 QAQ

** randrange
   #+BEGIN_SRC python
     def randrange(self, start, stop=None, step=1, _int=int):
             """Choose a random item from range(start, stop[, step]).
             This fixes the problem with randint() which includes the
             endpoint; in Python this is usually not what you want.
             """

             # This code is a bit messy to make it fast for the
             # common case while still doing adequate error checking.
             istart = _int(start)
             if istart != start:
                 raise ValueError("non-integer arg 1 for randrange()")
             if stop is None:
                 if istart > 0:
                     return self._randbelow(istart)
                 raise ValueError("empty range for randrange()")

             # stop argument supplied.
             istop = _int(stop)
             if istop != stop:
                 raise ValueError("non-integer stop for randrange()")
             width = istop - istart
             if step == 1 and width > 0:
                 return istart + self._randbelow(width)
             if step == 1:
                 raise ValueError("empty range for randrange() (%d,%d, %d)" % (istart, istop, width))

             # Non-unit step argument supplied.
             istep = _int(step)
             if istep != step:
                 raise ValueError("non-integer step for randrange()")
             if istep > 0:
                 n = (width + istep - 1) // istep
             elif istep < 0:
                 n = (width + istep + 1) // istep
             else:
                 raise ValueError("zero step for randrange()")

             if n <= 0:
                 raise ValueError("empty range for randrange()")

             return istart + istep*self._randbelow(n)
   #+END_SRC

   这个方法的实现依赖于 *_randbelow* 方法， *_randbelow* 方法生成 *[0, n)* 的整数随机数， 而 *randrange* 控制生成
   的随机数范围后生成后的随机数的处理。

   #+BEGIN_SRC python
     def _randbelow(self, n, int=int, maxsize=1<<BPF, type=type,
                        Method=_MethodType, BuiltinMethod=_BuiltinMethodType):
             "Return a random int in the range [0,n).  Raises ValueError if n==0."

             random = self.random
             getrandbits = self.getrandbits
             # Only call self.getrandbits if the original random() builtin method
             # has not been overridden or if a new getrandbits() was supplied.
             if type(random) is BuiltinMethod or type(getrandbits) is Method:
                 k = n.bit_length()  # don't use (n-1) here because n can be 1
                 r = getrandbits(k)          # 0 <= r < 2**k
                 while r >= n:
                     r = getrandbits(k)
                 return r
             ...
   #+END_SRC

   对于目前的 *Python*, *_randbelow* 会执行的部分大概就是这些， 生成随机数的核心部分为：
   #+BEGIN_SRC python
     k = n.bit_length()  # don't use (n-1) here because n can be 1
     r = getrandbits(k)          # 0 <= r < 2**k
     while r >= n:
         r = getrandbits(k)
     return r
   #+END_SRC

   通过 *getrandbits* 来控制生成的随机数的大小。

** choice
   #+BEGIN_SRC python
     def choice(self, seq):
         """Choose a random element from a non-empty sequence."""
         try:
             i = self._randbelow(len(seq))
         except ValueError:
             raise IndexError('Cannot choose from an empty sequence') from None
         return seq[i]
   #+END_SRC

   有了前面的内容的话， *choice* 的实现还是挺简单的.....

** shuffle   
   #+BEGIN_SRC python
     def shuffle(self, x, random=None):
         if random is None:
             randbelow = self._randbelow
             for i in reversed(range(1, len(x))):
                 # pick an element in x[:i+1] with which to exchange x[i]
                 j = randbelow(i+1)
                 x[i], x[j] = x[j], x[i]
         else:
             _int = int
             for i in reversed(range(1, len(x))):
                 # pick an element in x[:i+1] with which to exchange x[i]
                 j = _int(random() * (i+1))
                 x[i], x[j] = x[j], x[i]
   #+END_SRC

   通过源码可以发现， *shuffle* 这个方法的默认行为对 *小序列* 的效果不是很好。

** sample  
   #+BEGIN_SRC python
     def sample(self, population, k):
         if isinstance(population, _Set):
             population = tuple(population)
         if not isinstance(population, _Sequence):
             raise TypeError("Population must be a sequence or set.  For dicts, use list(d).")
         randbelow = self._randbelow
         n = len(population)
         if not 0 <= k <= n:
             raise ValueError("Sample larger than population or is negative")
         result = [None] * k
         setsize = 21        # size of a small set minus size of an empty list
         if k > 5:
             setsize += 4 ** _ceil(_log(k * 3, 4)) # table size for big sets
         if n <= setsize:
             # An n-length list is smaller than a k-length set
             pool = list(population)
             for i in range(k):         # invariant:  non-selected at [0,n-i)
                 j = randbelow(n-i)
                 result[i] = pool[j]
                 pool[j] = pool[n-i-1]   # move non-selected item into vacancy
         else:
             selected = set()
             selected_add = selected.add
             for i in range(k):
                 j = randbelow(n)
                 while j in selected:
                     j = randbelow(n)
                 selected_add(j)
                 result[i] = population[j]
         return result
   #+END_SRC

   这个函数的代码需要理解一下：
   1. 前期处理确定参数有效合法
   2. 当序列大小大于 *setsize* 时， 说明连续遇到相同的随机数的概率小， 采用不断
      循环得到不重复的元素的方法获取样本集合
   3. 当序列大小小于 *setsize* 时， 很有可能遇到相同的随机数， 所以使用简单的方式
      获取样本集合
   4. 对于小集合，这段代码保证已获取的元素不会重复获取， 同时未获取元素总是有可能被获取到
      #+BEGIN_SRC python
        for i in range(k):         # invariant:  non-selected at [0,n-i)
            j = randbelow(n-i)
            result[i] = pool[j]
            pool[j] = pool[n-i-1]   # move non-selected item into vacancy
      #+END_SRC

      *pool[j] = pool[n-i-1]* 使用未选择到的成员覆盖已选择的成员，当 *i* 增大时， *最后* 的元素
      将不会被选择到。

   好奇大小集合的判断依据是什么。

** choices
   #+BEGIN_SRC python
     def choices(self, population, weights=None, *, cum_weights=None, k=1):
         random = self.random
         if cum_weights is None:
             if weights is None:
                 _int = int
                 total = len(population)
                 return [population[_int(random() * total)] for i in range(k)]
             cum_weights = list(_itertools.accumulate(weights))
         elif weights is not None:
             raise TypeError('Cannot specify both weights and cumulative weights')
         if len(cum_weights) != len(population):
             raise ValueError('The number of weights does not match the population')
         bisect = _bisect.bisect
         total = cum_weights[-1]
         hi = len(cum_weights) - 1
         return [population[bisect(cum_weights, random() * total, 0, hi)]
                 for i in range(k)]
   #+END_SRC

   这个也需要理一下：
   1. 如果只指定了参数 *k*, 那么直接从 *population* 中选择 *k* 个元素返回
   2. 如果指定 *weights* 而没有指定 *cum_weights*, 那么 *cum_weights* 等于 *weights* 经过
      [[https://docs.python.org/3/library/itertools.html#itertools.accumulate][itertools.accumulate]] 处理后的结果
   3. 最后通过 [[https://docs.python.org/3.6/library/bisect.html][bisect]] 和 *cum_weights* 来选择元素

   感觉模块 *bisect* 挺有趣的。

* 相关链接
  + [[https://github.com/python/cpython/blob/3.6/Modules/_randommodule.c][_randommodule.c]]
  + [[https://github.com/python/cpython/blob/3.6/Lib/random.py][random 源码链接]]
  + [[https://docs.python.org/3/library/random.html][random 文档链接]]
