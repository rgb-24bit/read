#+TITLE:      base
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#preconditions][Preconditions]]
- [[#调整策略][调整策略]]
- [[#absent--present][Absent & Present]]
- [[#optional][Optional]]
- [[#调整策略-1][调整策略]]
- [[#enumsgetfield][Enums.getField]]
- [[#objects][Objects]]

* Preconditions
  这个类存在第三方依赖， 但是都是 *注解类*, 对源码的阅读没有太多影响。

  #+BEGIN_SRC java
    public final class Preconditions {
      private Preconditions() {}
    }
  #+END_SRC
  
  ~final~ 修饰， 这个类不能被继承， ~private~ 的构造方法， 这个类不能实例化。
  
  内部的大多数方法都有很多个 *重载*, 还是先看一下没有重载的几个方法：
  #+BEGIN_SRC java
    static String format(@NullableDecl String template, @NullableDecl Object... args) {
      template = String.valueOf(template); // null -> "null"

      args = args == null ? new Object[] {"(Object[])null"} : args;

      // start substituting the arguments into the '%s' placeholders
      StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
      int templateStart = 0;
      int i = 0;
      while (i < args.length) {
        int placeholderStart = template.indexOf("%s", templateStart);
        if (placeholderStart == -1) {
          break;
        }
        builder.append(template, templateStart, placeholderStart);
        builder.append(args[i++]);
        templateStart = placeholderStart + 2;
      }
      builder.append(template, templateStart, template.length());

      // if we run out of placeholders, append the extra args in square braces
      if (i < args.length) {
        builder.append(" [");
        builder.append(args[i++]);
        while (i < args.length) {
          builder.append(", ");
          builder.append(args[i++]);
        }
        builder.append(']');
      }

      return builder.toString();
    }
  #+END_SRC

  用到了 *可变长参数*, 虽然在我买的教材上没有讲到这个东西， 但是搜了一下， 看懂代码还是不难的。

  #+BEGIN_SRC java
    template = String.valueOf(template); // null -> "null"
  #+END_SRC

  用的是 ~String.valueOf(Object obj)~ 这个重载， 如果参数是 ~null~, 那么返回字符串形式的 ~null~.

  否则， 返回 ~obj.toString~. 而字符串 ~toString~ 就是它本身。

  对 ~args~ 的处理没什么好说的， 比较感兴趣的是 ~builder~ 这部分。

  这个 ~format~ 方法只会处理 ~template~ 中的 ~%s~, 虽然功能上没有 ~String.format~ 强大， 但是
  ~template~ 允许空值， 使用上就安全不少。

  ~builder.append(template. templateStart. placeholderStart)~, 用的是这个重载：
  #+BEGIN_SRC java
    append(CharSequence s, int start, int end)
  #+END_SRC

  原来 ~String~ 和 ~StringBuilder~ 这些都是 ~CharSequence~ 的子类。

  而 ~builder.append(args[i++])~ 使用的则是：
  #+BEGIN_SRC java
    public StringBuilder append(Object obj)
  #+END_SRC

  内部好像是调用 ~String.valueOf(obj)~.

  #+BEGIN_SRC java
    if (i < args.length) {
      builder.append(" [");
      builder.append(args[i++]);
      while (i < args.length) {
        builder.append(", ");
        builder.append(args[i++]);
      }
      builder.append(']');
    }
  #+END_SRC

  完整的数组的话， 感觉可以用 ~Arrays.toString(args)~ 来代替这个步骤， 但是这个数组需要截断一部分。

  三个重载超级多的方法：
  #+BEGIN_SRC java
    // 判断 expression 是否为 true, 如果为 false 就抛出 IllegalArgumentException
    public static void checkArgument(boolean expression, ...);

    // 判断 expression 是否为 true, 如果为 false, 就抛出 IllegalStateException
    public static void checkState(boolean expression, ...);

    // 判断 reference 是否为 null, 如果是 null, 就抛出 NullPointerException, 否则返回 reference
    public static <T> T checkNotNull(T reference, ...);
  #+END_SRC
  
  这三个方法的重载和文档， 差不多都有 ~1290~ 行了 @_@.

  剩下的几个方法：
  #+BEGIN_SRC java
    // 判断 index 是否合法， 如果 index < 0 || index >= size 就抛出 IndexOutOfBoundsException
    public static int checkElementIndex(int index, int size);
    public static int checkElementIndex(int index, int size, @NullableDecl String desc);
    private static String badElementIndex(int index, int size, @NullableDecl String desc);

    // 一样判断 index
    public static int checkPositionIndex(int index, int size);
    public static int checkPositionIndex(int index, int size, @NullableDecl String desc);
    private static String badPositionIndex(int index, int size, @NullableDecl String desc);

    // 指定范围判断 index
    public static void checkPositionIndexes(int start, int end, int size);
    private static String badPositionIndexes(int start, int end, int size);
  #+END_SRC

  ~Java~ 果然哆嗦......

  感觉 ~checkElementIndex~ 和 ~checkPositionIndex~ 的功能差不多......

* 调整策略
  看 ~guava~ 的主要目的是学习 ~Java~ 的使用， 而不是 ~guava~ 的使用。 像之前那个类中各种重载， 功能上相近的方法就不需要重复了。

  简单的代码简单略过， 有意思的代码在仔细研究。

* Absent & Present
  ~Absent~ 是对 ~Optional~ 这个类的继承， 有点疑惑的是这个类里面并没有 ~import java.util.Optional~ ？

  类 ~Optional~ 属于 ~java8~ 的新特性， 似乎经常和 ~lambda~ 放在一起使用。

  这两者我都还没有太多的了解， 但是找到了两篇很好的博客：
  + [[https://lw900925.github.io/java/java8-optional.html][Java 8新特性（三）：Optional类]]
  + [[http://blog.oneapm.com/apm-tech/226.html][深入浅出 Java 8 Lambda 表达式]]

  卧槽， ~Optional~ 原来在 ~base~ 这个包有实现一个 ~Optional~, 难怪没有 ~import~.

  emmmm, 看 ~Python~ 代码中发现前面没有定义的东西估计是在后面， 然鹅， ~Java~ 不仅后面可能有， 同一个包里面还需要了解一下......

  先去看 ~Optional~ 的代码。
  
  这个的代码还是和 ~Present~ 放在一起看比较好。

  然而这两个的代码还真的没有什么看头， 略过略过。

* Optional
  #+BEGIN_SRC java
    import java.io.Serializable;
    import java.util.Iterator;
    import java.util.Set;
  #+END_SRC

  这三个 ~Iterator~ 完全不熟， ~Set~ 和 ~Serializable~ 还有点了解。

  感觉上 ~Iterator~ 是个好东西， 虽然只是一个接口， 功能还是要自己实现 QAQ

  ~Optional~ 中功能的对应实现：
  #+BEGIN_SRC java
    //  equivalent to Optional.empty
    public static <T> Optional<T> absent() {
      return Absent.withType();
    }

    // equivalent to Optional.of
    public static <T> Optional<T> of(T reference) {
      return new Present<T>(checkNotNull(reference));
    }

    // equivalent to Optional.ofNullable
    public static <T> Optional<T> fromNullable(@NullableDecl T nullableReference) {
      return (nullableReference == null) ? Optional.<T>absent() : new Present<T>(nullableReference);
    }
  #+END_SRC
 
  emmm, ~Absent~ 和 ~Present~...

  昨天和今天的代码阅读下来， 我明显的感受到了 ~Java~ 和 ~Python~ 中命名风格的不同， 多的不说， 就说这长度， ~Java~ 厉害。

  ~Optional.<T>absent()~ 这个泛型的使用还是头一次见， 在看看 ~absent~ 的声明， 这个可以记一下。

  剩下的代码， 略过。

* 调整策略
  我觉得这样的效率还是有点低， 相当多的时间放在了没有多少用的东西上面。

  而且要全部看完的话， 各种依赖关系， 工作量还真不小。

  接下来的阅读方式修改为： 有用的， 摘取代码片段阅读， 无用的， 简单略过。
* Enums.getField
  #+BEGIN_SRC java
    public static Field getField(Enum<?> enumValue) {
      Class<?> clazz = enumValue.getDeclaringClass();
      try {
        return clazz.getDeclaredField(enumValue.name());
      } catch (NoSuchFieldException impossible) {
        throw new AssertionError(impossible);
      }
    }
  #+END_SRC

  ~Java~ 反射， 昨天了解了一下， 今天就遇上了。

  首先获取类， 在根据字段名获取字段。

* Objects
  这个类的两个方法可以看一下：
  #+BEGIN_SRC java
    public final class Objects extends ExtraObjectsMethodsForWeb {
      private Objects() {}

      //  java 7 and later => Objects.equals(java.lang.Object, java.lang.Object)
      public static boolean equal(@NullableDecl Object a, @NullableDecl Object b) {
        return a == b || (a != null && a.equals(b));
      }

      // java 7 and later =>  Objects.hash(java.lang.Object...)
      public static int hashCode(@NullableDecl Object... objects) {
        return Arrays.hashCode(objects);
      }
    }
  #+END_SRC

  第一个 ~equal~ 判断两个可能为 ~null~ 的对象是否相等， ~Java7~ 可以用 ~Object.equals~ 代替。

  而第二个 ~hashCode~ 可以获取一串对象的 ~hash~ 值， 到了 ~Java7~ 也可以用 ~Object.hash(java.lang.Object...)~ 代替。

  emmm, 感觉 ~guava~ 存在的时间好久远了， 好多东西到了高版本都有替代的了 QAQ

