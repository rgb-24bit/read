#+TITLE:      compat
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#主要代码][主要代码]]
- [[#pypy][PyPy]]

* 主要代码
  #+BEGIN_SRC python
    import sys

    PY2 = sys.version_info[0] == 2
    _identity = lambda x: x


    if not PY2:
        text_type = str
        string_types = (str,)
        integer_types = (int,)

        iterkeys = lambda d: iter(d.keys())
        itervalues = lambda d: iter(d.values())
        iteritems = lambda d: iter(d.items())

        from inspect import getfullargspec as getargspec
        from io import StringIO

        def reraise(tp, value, tb=None):
            if value.__traceback__ is not tb:
                raise value.with_traceback(tb)
            raise value

        implements_to_string = _identity

    else:
        text_type = unicode
        string_types = (str, unicode)
        integer_types = (int, long)

        iterkeys = lambda d: d.iterkeys()
        itervalues = lambda d: d.itervalues()
        iteritems = lambda d: d.iteritems()

        from inspect import getargspec
        from cStringIO import StringIO

        exec('def reraise(tp, value, tb=None):\n raise tp, value, tb')

        def implements_to_string(cls):
            cls.__unicode__ = cls.__str__
            cls.__str__ = lambda x: x.__unicode__().encode('utf-8')
            return cls


    def with_metaclass(meta, *bases):
        """Create a base class with a metaclass."""
        # This requires a bit of explanation: the basic idea is to make a
        # dummy metaclass for one level of class instantiation that replaces
        # itself with the actual metaclass.
        class metaclass(type):
            def __new__(cls, name, this_bases, d):
                return meta(name, bases, d)
        return type.__new__(metaclass, 'temporary_class', (), {})
  #+END_SRC

  这部分的代码很简单， 比较有趣的是模块 ~inspect~ 的作用。

  另外就是： ~implements_to_string~ 和 ~with_metaclass~.

  ~implements_to_string~ 应该是用于定义一个类转换为 ~str~ 时的行为。

  主要是对 ~Py2~ 的 ~__unicode__~ 方法的处理吧。

  然后就是 ~with_metaclass~ 了， 其实这个函数可以通过 ~six~ 模块导入：
  #+BEGIN_SRC python
    from six import with_metaclass
  #+END_SRC

  通过这里的源码， 也可以了解其原理。

* PyPy
  #+BEGIN_SRC python
    # Certain versions of pypy have a bug where clearing the exception stack
    # breaks the __exit__ function in a very peculiar way.  The second level of
    # exception blocks is necessary because pypy seems to forget to check if an
    # exception happened until the next bytecode instruction?
    #
    # Relevant PyPy bugfix commit:
    # https://bitbucket.org/pypy/pypy/commits/77ecf91c635a287e88e60d8ddb0f4e9df4003301
    # According to ronan on #pypy IRC, it is released in PyPy2 2.3 and later
    # versions.
    #
    # Ubuntu 14.04 has PyPy 2.2.1, which does exhibit this bug.
    BROKEN_PYPY_CTXMGR_EXIT = False
    if hasattr(sys, 'pypy_version_info'):
        class _Mgr(object):
            def __enter__(self):
                return self
            def __exit__(self, *args):
                if hasattr(sys, 'exc_clear'):
                    # Python 3 (PyPy3) doesn't have exc_clear
                    sys.exc_clear()
        try:
            try:
                with _Mgr():
                    raise AssertionError()
            except:
                raise
        except TypeError:
            BROKEN_PYPY_CTXMGR_EXIT = True
        except AssertionError:
            pass
  #+END_SRC
  
  兼容 ~PyPy~ 这种事就暂时不考虑的， 都还没用过......

