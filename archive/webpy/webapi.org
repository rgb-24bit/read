#+TITLE:      webapi
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#reread][Reread]]
- [[#import][import]]
- [[#instances][instances]]
  - [[#config][config]]
  - [[#ctx][ctx]]
- [[#class-httperror][class HTTPError]]
  - [[#function-header][function header]]
- [[#function-_status_code][function _status_code]]
- [[#class-for-status-code][class for status code]]
- [[#function-rawinput][function rawinput]]
- [[#function-input][function input]]
- [[#function-data][function data]]
- [[#function-setcookie][function setcookie]]
- [[#function-decode_cookie][function decode_cookie]]
- [[#function-parse_cookieshttp_cookie][function parse_cookies(http_cookie):]]
- [[#function-cookies][function cookies]]
- [[#function-debug][function debug]]
- [[#完成][完成]]

* Reread
  前一段时间尝试了阅读 ~webapi~ 模块的源码， 但由于相关知识不足的问题导致阅读质量
  很差， 因此选择重读。

  前一段时间的阅读笔记： [[file:archive/webapi.org][webapi]].
  
* import
  这个模块依赖的模块：
  #+BEGIN_SRC python
    from __future__ import print_function

    import sys, cgi, pprint, urllib
    from .utils import storage, storify, threadeddict, dictadd, intget, safestr

    from .py3helpers import PY2, urljoin, string_types

    try:
        from urllib.parse import unquote, quote
        from http.cookies import Morsel
    except ImportError:
        from urllib import unquote, quote
        from Cookie import Morsel

    from io import StringIO, BytesIO
  #+END_SRC

  依赖的模块中， ~utils~ 和 ~py3helpers~ 的源码已经读过了， 问题不大。

  ~cgi~ 和 ~pprint~ 这两个模块不太熟悉， 可以了解一下。

  ~urllib~ 了解过， 但用的比较少， 不是很熟悉。

  ~Cookie~ 就没用过了。

  ~io~ 这个模块目前就用过 ~io.open~.

* instances
  前一次阅读的过程中对这些 *实例* 的调用产生了一些疑惑， 后来尝试了一下，
  发现其他模块中 ~import~ 这些实例的话， 不同模块 ~import~ 的是同一个对象。

  也就是说在一个模块中对 *实例* 的属性进行了修改， 会反应到同样 ~import~ 了这个 *实例*
  的模块中， 包括当前模块本身。

  而 ~ctx~ 对象的特殊性， 使得它在除了 *主线程* 中的唯一 *实例* 外， 在其他线程中还会单独存在
  一个实例， 保存那个线程下的上下文。

** config
   #+BEGIN_SRC python
     config = storage()
     config.__doc__ = """
     A configuration object for various aspects of web.py.

     `debug`
        : when True, enables reloading, disabled template caching and sets internalerror to debugerror.
     """
   #+END_SRC

   配置用的一个实例， 简单直接。

** ctx
   #+BEGIN_SRC python
     ctx = context = threadeddict()

     ctx.__doc__ = """
     A `storage` object containing various information about the request:

     `environ` (aka `env`)
        : A dictionary containing the standard WSGI environment variables.

     `host`
        : The domain (`Host` header) requested by the user.

     `home`
        : The base path for the application.

     `ip`
        : The IP address of the requester.

     `method`
        : The HTTP method used.

     `path`
        : The path request.

     `query`
        : If there are no query arguments, the empty string. Otherwise, a `?` followed
          by the query string.

     `fullpath`
        : The full path requested, including query arguments (`== path + query`).

     ### Response Data

     `status` (default: "200 OK")
        : The status code to be used in the response.

     `headers`
        : A list of 2-tuples to be used in the response.

     `output`
        : A string to be used as the response.
     """
   #+END_SRC

   应该是用来保存 *上下文* 的对象， 而且是 ~threadeddict~ 的 *实例*.

   ~threadeddict~ 是在 ~utils~ 模块中定义的， 该对象的实例在各个线程下相对独立， 互不影响。

   也就是说 ~ctx~ 可以分别保存多个线程的上下文， 互不影响， 且调用属性方式相同。

* class HTTPError
  一个自定义异常:
  #+BEGIN_SRC python
    class HTTPError(Exception):
        def __init__(self, status, headers={}, data=""):
            ctx.status = status
            for k, v in headers.items():
                header(k, v)
            self.data = data
            Exception.__init__(self, status)
  #+END_SRC

  异常的 *构造函数* 中， 修改了 ~ctx.status~, 并将 ~data~ 绑定到自身的实例上。

  也就是说， 当出现 ~HTTPError~ 的时候， 会将 *状态码* 保存到当前的上下文之中。

  也可以预测， 使用 ~HTTPError~ 的地方， 必然知道返回的 *状态码*.

** function header
   *构造函数* 中使用了 ~header~ 函数：
   #+BEGIN_SRC python
     def header(hdr, value, unique=False):
         """
         Adds the header `hdr: value` with the response.

         If `unique` is True and a header with that name already exists,
         it doesn't add a new one.
         """
         hdr, value = safestr(hdr), safestr(value)
         # protection against HTTP response splitting attack
         if '\n' in hdr or '\r' in hdr or '\n' in value or '\r' in value:
             raise ValueError('invalid characters in header')
         if unique is True:
             for h, v in ctx.headers:
                 if h.lower() == hdr.lower(): return

         ctx.headers.append((hdr, value))
   #+END_SRC

   很明显， 这个是用来将 *响应头* 保存到上下文中的函数。

   首先， 将头信息的键值转换为 ~str~, 包整内部数据类型的统一。

   *头信息* 中的数据是不存在 *换行符* 的， 所以进行了检查。

   循环中判断头信息的 *键* 是否重复。

   ~headers~ 是一个 ~list~.

   目前可以明白 ~HTTPError~ 的基本工作流程了：
   1. 将状态码保存到当前上下文
   2. 更新当前上下文的头信息
   3. 将 ~data~ 绑定到异常实例

* function _status_code
  用来构造类的一个函数：
  #+BEGIN_SRC python
    def _status_code(status, data=None, classname=None, docstring=None):
        if data is None:
            data = status.split(" ", 1)[1]
        classname = status.split(" ", 1)[1].replace(' ', '') # 304 Not Modified -> NotModified
        docstring = docstring or '`%s` status' % status

        def __init__(self, data=data, headers={}):
            HTTPError.__init__(self, status, headers, data)

        # trick to create class dynamically with dynamic docstring.
        return type(classname, (HTTPError, object), {
            '__doc__': docstring,
            '__init__': __init__
        })
  #+END_SRC

  使用这个函数创建了四个类：
  #+BEGIN_SRC python
    ok = OK = _status_code("200 OK", data="")
    created = Created = _status_code("201 Created")
    accepted = Accepted = _status_code("202 Accepted")
    nocontent = NoContent = _status_code("204 No Content")
  #+END_SRC
  
  感觉吧， 函数前面的 ~_~ 是很有必要的 ！

* class for status code
  针对 *状态码* 的异常类：
  #+BEGIN_SRC python
    __all__ = [
        "HTTPError",

        # 200, 201, 202, 204
        "OK", "Created", "Accepted", "NoContent",
        "ok", "created", "accepted", "nocontent",

        # 301, 302, 303, 304, 307
        "Redirect", "Found", "SeeOther", "NotModified", "TempRedirect",
        "redirect", "found", "seeother", "notmodified", "tempredirect",

        # 400, 401, 403, 404, 405, 406, 409, 410, 412, 415, 451
        "BadRequest", "Unauthorized", "Forbidden", "NotFound", "NoMethod", "NotAcceptable", "Conflict", "Gone", "PreconditionFailed", "UnsupportedMediaType", "UnavailableForLegalReasons",
        "badrequest", "unauthorized", "forbidden", "notfound", "nomethod", "notacceptable", "conflict", "gone", "preconditionfailed", "unsupportedmediatype", "unavailableforlegalreasons",

        # 500
        "InternalError",
        "internalerror",
    ]
  #+END_SRC
  
  看 ~__all__~ 变量的部分就可以明白有多少个类了。

  这部分的代码主要就是针对不同的状态码的操作， 相当繁琐。

  但是浏览还是有助于了解 ~HTTP~ 协议相关的内容。

  留个链接： [[https://github.com/webpy/webpy/blob/master/web/webapi.py#L54][HTTPError]].

* function rawinput
  和 ~raw_input~ 就差个 ~_~:
  #+BEGIN_SRC python
    def rawinput(method=None):
        """Returns storage object with GET or POST arguments.
        """
        method = method or "both"

        def dictify(fs):
            # hack to make web.input work with enctype='text/plain.
            if fs.list is None:
                fs.list = []

            return dict([(k, fs[k]) for k in fs.keys()])

        e = ctx.env.copy()
        a = b = {}

        if method.lower() in ['both', 'post', 'put']:
            if e['REQUEST_METHOD'] in ['POST', 'PUT']:
                if e.get('CONTENT_TYPE', '').lower().startswith('multipart/'):
                    # since wsgi.input is directly passed to cgi.FieldStorage,
                    # it can not be called multiple times. Saving the FieldStorage
                    # object in ctx to allow calling web.input multiple times.
                    a = ctx.get('_fieldstorage')
                    if not a:
                        fp = e['wsgi.input']
                        a = cgi.FieldStorage(fp=fp, environ=e, keep_blank_values=1)
                        ctx._fieldstorage = a
                else:
                    d = data()
                    if PY2 and isinstance(d, unicode):
                        d = d.encode('utf-8')
                    fp = BytesIO(d)
                    a = cgi.FieldStorage(fp=fp, environ=e, keep_blank_values=1)
                a = dictify(a)

        if method.lower() in ['both', 'get']:
            e['REQUEST_METHOD'] = 'GET'
            b = dictify(cgi.FieldStorage(environ=e, keep_blank_values=1))

        def process_fieldstorage(fs):
            if isinstance(fs, list):
                return [process_fieldstorage(x) for x in fs]
            elif fs.filename is None:
                return fs.value
            else:
                return fs

        return storage([(k, process_fieldstorage(v)) for k, v in dictadd(b, a).items()])
  #+END_SRC
 
  首先是嵌套函数 ~dictify~, 目测和 ~Storage~ 对象有关。

  关于 ~Storage~ 的内容忘了不少， 重新打开 ~utils~ 看了一下， 发现
  ~Storage~ 是继承自 ~dict~ 的， 并重构的 *设置属性* 的魔法方法。

  使得设置与获取属性的时候就等价于设置获取字典的键值。

  ~utils~ 中定义了一个函数 ~storify~, 将一个映射对象转化为 ~storage~ 对象。

  这个 ~dictify~ 的部分作用应该就是将 ~storage~ 转化为 ~dict~.

  然后， 获取了 *上下文* 中的 ~env~ 对象的浅拷贝。

  ~a = b = {}~, a 和 b 都是同一个对象。

  看了一下 ~CGI~ 相关的内容， 发现 ~ctx~ 中的部分属性是针对 ~CGI~ 的。

  比如 ~ctx.env~, 保存了 *CGI 环境变量*.

  通过 ~cgi.FieldStorage~ 可以获取发送的数据。
  
  emmm, 对 ~CGI~ 有了了解， 但对接口不熟， 暂时就这样。

* function input
  #+BEGIN_SRC python
    def input(*requireds, **defaults):
        """
        Returns a `storage` object with the GET and POST arguments.
        See `storify` for how `requireds` and `defaults` work.
        """
        _method = defaults.pop('_method', 'both')
        out = rawinput(_method)
        try:
            defaults.setdefault('_unicode', True) # force unicode conversion by default.
            return storify(out, *requireds, **defaults)
        except KeyError:
            raise badrequest()
  #+END_SRC

  这个函数主要是对 ~rawinput~ 的数据进行处理， 区简单的看了一下 ~cgi~ 的相关接口，
  才发现 ~cgi.FieldStorage~ 是一个 *类*, 我一直认为是一个方法。

  如果是一个类的话就好理解一些了。
  
* function data
  从上下文的 ~ctx.env['wsgi.input']~ 读取数据， 和前面的函数还是有关系的。

* function setcookie
  这方面的内容和 ~HTTP~ 协议相关度很高， 需要了解 ☞ [[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E5%88%9B%E5%BB%BACookie][创建Cookie]].

  然后再来看这个函数：
  #+BEGIN_SRC python
    def setcookie(name, value, expires='', domain=None,
                  secure=False, httponly=False, path=None):
        """Sets a cookie."""
        morsel = Morsel()
        name, value = safestr(name), safestr(value)
        morsel.set(name, value, quote(value))
        if isinstance(expires, int) and expires < 0:
            expires = -1000000000
        morsel['expires'] = expires
        morsel['path'] = path or ctx.homepath+'/'
        if domain:
            morsel['domain'] = domain
        if secure:
            morsel['secure'] = secure
        value = morsel.OutputString()
        if httponly:
            value += '; httponly'
        header('Set-Cookie', value)
  #+END_SRC

  首先看参数： 参数都是和 ~Cookie~ 的设置相关的， 没毛病。

  然后， 是 ~Morsel~.

  ~Morsel~ 的实例有 ~Morsel.value~ 和 ~Morsel.code_value~ 属性， 分别为 *值* 和 *编码的值*.

  不过 ~set~ 这个返回会被弃用......

  后面的东西就没有什么好说的了。 简单的设置值。

* function decode_cookie
  #+BEGIN_SRC python
    def decode_cookie(value):
        r"""Safely decodes a cookie value to unicode.

        Tries us-ascii, utf-8 and io8859 encodings, in that order.

        >>> decode_cookie('')
        u''
        >>> decode_cookie('asdf')
        u'asdf'
        >>> decode_cookie('foo \xC3\xA9 bar')
        u'foo \xe9 bar'
        >>> decode_cookie('foo \xE9 bar')
        u'foo \xe9 bar'
        """
        try:
            # First try plain ASCII encoding
            return unicode(value, 'us-ascii')
        except UnicodeError:
            # Then try UTF-8, and if that fails, ISO8859
            try:
                return unicode(value, 'utf-8')
            except UnicodeError:
                return unicode(value, 'iso8859', 'ignore')
  #+END_SRC

  emmm, 目测是针对 ~Python2~ 的， 毕竟 ~Python3~ 已经遗弃了 ~unicode~ 函数。

  不过， 编码这个问题是真的烦啊......

* function parse_cookies(http_cookie):
  ~Cookie~ 的解析， 感觉挺不错的：
  #+BEGIN_SRC python
    def parse_cookies(http_cookie):
        """Parse a HTTP_COOKIE header and return dict of cookie names and decoded values.
        """
        #print "parse_cookies"
        if '"' in http_cookie:
            # HTTP_COOKIE has quotes in it, use slow but correct cookie parsing
            cookie = Cookie.SimpleCookie()
            try:
                cookie.load(http_cookie)
            except Cookie.CookieError:
                # If HTTP_COOKIE header is malformed, try at least to load the cookies we can by
                # first splitting on ';' and loading each attr=value pair separately
                cookie = Cookie.SimpleCookie()
                for attr_value in http_cookie.split(';'):
                    try:
                        cookie.load(attr_value)
                    except Cookie.CookieError:
                        pass
            cookies = dict([(k, unquote(v.value)) for k, v in cookie.iteritems()])
        else:
            # HTTP_COOKIE doesn't have quotes, use fast cookie parsing
            cookies = {}
            for key_value in http_cookie.split(';'):
                key_value = key_value.split('=', 1)
                if len(key_value) == 2:
                    key, value = key_value
                    cookies[key.strip()] = unquote(value.strip())
        return cookies
  #+END_SRC
  
  感觉最好的一个操作是 ~key_value.split('=', 1)~ 这一段。

  设置最大 *分割* 次数的一种使用。

* function cookies
  #+BEGIN_SRC python
    def cookies(*requireds, **defaults):
        r"""Returns a `storage` object with all the request cookies in it.

        See `storify` for how `requireds` and `defaults` work.

        This is forgiving on bad HTTP_COOKIE input, it tries to parse at least
        the cookies it can.

        The values are converted to unicode if _unicode=True is passed.
        """
        # If _unicode=True is specified, use decode_cookie to convert cookie value to unicode
        if defaults.get("_unicode") is True:
            defaults['_unicode'] = decode_cookie

        # parse cookie string and cache the result for next time.
        if '_parsed_cookies' not in ctx:
            http_cookie = ctx.env.get("HTTP_COOKIE", "")
            ctx._parsed_cookies = parse_cookies(http_cookie)

        try:
            return storify(ctx._parsed_cookies, *requireds, **defaults)
        except KeyError:
            badrequest()
            raise StopIteration()
  #+END_SRC

  函数的文档说的挺清楚的。

* function debug
  ~pprint~ 居然只是在这里用了一下：
  #+BEGIN_SRC python
    def debug(*args):
        """
        Prints a prettyprinted version of `args` to stderr.
        """
        try:
            out = ctx.environ['wsgi.errors']
        except:
            out = sys.stderr
        for arg in args:
            print(pprint.pformat(arg), file=out)
        return ''
  #+END_SRC

  个人感觉 ~pprint~ 的美化输出的能力没有想象的那么好......

  + _debugwrite :: 这个地方的操作有点看不懂

  #+BEGIN_SRC python
    def _debugwrite(x):
        try:
            out = ctx.environ['wsgi.errors']
        except:
            out = sys.stderr
        out.write(x)
    debug.write = _debugwrite
  #+END_SRC

  所以说， 函数这个对象也可以这样设置属性 ？

  试了一下， 还真的可以......

  然而， 不给别人说别人估计猜不到这个函数还有一个属性也是函数吧......

  这个问题要好好了解一下

* 完成
  基本完成了这个模块源码的阅读， 基础感觉还是不够好......

