#+TITLE:      borg
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#文档][文档]]
- [[#代码][代码]]
- [[#输出][输出]]
- [[#理解][理解]]

* 文档
  #+BEGIN_SRC python
    """
    *What is this pattern about?
    The Borg pattern (also known as the Monostate pattern) is a way to
    implement singleton behavior, but instead of having only one instance
    of a class, there are multiple instances that share the same state. In
    other words, the focus is on sharing state instead of sharing instance
    identity.

    *What does this example do?
    To understand the implementation of this pattern in Python, it is
    important to know that, in Python, instance attributes are stored in a
    attribute dictionary called __dict__. Usually, each instance will have
    its own dictionary, but the Borg pattern modifies this so that all
    instances have the same dictionary.
    In this example, the __shared_state attribute will be the dictionary
    shared between all instances, and this is ensured by assigining
    __shared_state to the __dict__ variable when initializing a new
    instance (i.e., in the __init__ method). Other attributes are usually
    added to the instance's attribute dictionary, but, since the attribute
    dictionary itself is shared (which is __shared_state), all other
    attributes will also be shared.
    For this reason, when the attribute self.state is modified using
    instance rm2, the value of self.state in instance rm1 also chages. The
    same happends if self.state is modified using rm3, which is an
    instance from a subclass.
    Notice that even though they share attributes, the instances are not
    the same, as seen by their ids.

    *Where is the pattern used practically?
    Sharing state is useful in applications like managing database connections:
    https://github.com/onetwopunch/pythonDbTemplate/blob/master/database.py

    *References:
    https://fkromer.github.io/python-pattern-references/design/#singleton

    *TL;DR80
    Provides singletone-like behavior sharing state between instances.
    """
  #+END_SRC

  *References*:
  + https://fkromer.github.io/python-pattern-references/design/#singleton

* 代码
  #+BEGIN_SRC python
    class Borg(object):
        __shared_state = {}

        def __init__(self):
            self.__dict__ = self.__shared_state
            self.state = 'Init'

        def __str__(self):
            return self.state


    class YourBorg(Borg):
        pass


    if __name__ == '__main__':
        rm1 = Borg()
        rm2 = Borg()

        rm1.state = 'Idle'
        rm2.state = 'Running'

        print('rm1: {0}'.format(rm1))
        print('rm2: {0}'.format(rm2))

        rm2.state = 'Zombie'

        print('rm1: {0}'.format(rm1))
        print('rm2: {0}'.format(rm2))

        print('rm1 id: {0}'.format(id(rm1)))
        print('rm2 id: {0}'.format(id(rm2)))

        rm3 = YourBorg()

        print('rm1: {0}'.format(rm1))
        print('rm2: {0}'.format(rm2))
        print('rm3: {0}'.format(rm3))
  #+END_SRC

* 输出
  #+BEGIN_EXAMPLE
    ### OUTPUT ###
    # rm1: Running
    # rm2: Running
    # rm1: Zombie
    # rm2: Zombie
    # rm1 id: 140732837899224
    # rm2 id: 140732837899296
    # rm1: Init
    # rm2: Init
    # rm3: Init
  #+END_EXAMPLE

* 理解
  ~borg~ 模式和 *单例模式* 还是有区别的， *单例模式* 是全局中只存在一个实例，
  而 ~borg~ 允许存在多个实例， 但是这些实例之间的状态是共享的。

  *单例模式* 相对容易理解一些， 但是 ~borg~ 模式的理解相对要困难一些。

  感觉很贴近 *单例模式* 的一个例子就是 *引用类型* 的操作了， 单个实例同时存在多个引用，
  在一个引用处进行修改， 做出的修改能够立即反馈到其他引用上。

  对于 ~borg~ 模式， 感觉 ~Python~ 中 *类* 和 *实例* 之间的关系就是一个 ~borg~ 模式的例子：
  不同的 *实例* 之间共享 *类* 属性， 而 *实例* 还可以拥有自己的 *实例属性*.

  所以， 感觉在 ~Python~ 中， 用 *类* 和 *实例* 来创建 ~borg~ 模式也不错。

  单例模式:
  #+BEGIN_SRC python
    class Singletone(object):
        __instance = None

        def __new__(cls, *args, **kwargs):
            if not cls.__instance:
                parent = super(Singletone, cls)
                cls.__instance = parent.__new__(cls, *args, **kwargs)
            return cls.__instance

        def __init__(self):
            Singletone.__instance = self


    if __name__ == '__main__':
        sl = Singletone()
        sl2 = Singletone()

        print(sl is sl2)
  #+END_SRC

  执行结果:
  #+BEGIN_EXAMPLE
    True
  #+END_EXAMPLE
  
  ~borg~ 模式参考示例代码就好， 不过如果每个实例可以拥有不共享的属性的话，
  还算是 ~borg~ 模式吗 ？

