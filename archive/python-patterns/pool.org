#+TITLE:      pool
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#文档][文档]]
- [[#代码][代码]]
- [[#输出][输出]]
- [[#理解][理解]]

* 文档
  #+BEGIN_SRC python
    """
    *What is this pattern about?
    This pattern is used when creating an object is costly (and they are
    created frequently) but only a few are used at a time. With a Pool we
    can manage those instances we have as of now by caching them. Now it
    is possible to skip the costly creation of an object if one is
    available in the pool.
    A pool allows to 'check out' an inactive object and then to return it.
    If none are available the pool creates one to provide without wait.

    *What does this example do?
    In this example queue.Queue is used to create the pool (wrapped in a
    custom ObjectPool object to use with the with statement), and it is
    populated with strings.
    As we can see, the first string object put in "yam" is USED by the
    with statement. But because it is released back into the pool
    afterwards it is reused by the explicit call to sample_queue.get().
    Same thing happens with "sam", when the ObjectPool created insided the
    function is deleted (by the GC) and the object is returned.

    *Where is the pattern used practically?

    *References:
    http://stackoverflow.com/questions/1514120/python-implementation-of-the-object-pool-design-pattern
    https://sourcemaking.com/design_patterns/object_pool

    *TL;DR80
    Stores a set of initialized objects kept ready to use.
    """
  #+END_SRC
  
  *References*:
  + http://stackoverflow.com/questions/1514120/python-implementation-of-the-object-pool-design-pattern
  + https://sourcemaking.com/design_patterns/object_pool

* 代码
  #+BEGIN_SRC python
    class ObjectPool(object):

        def __init__(self, queue, auto_get=False):
            self._queue = queue
            self.item = self._queue.get() if auto_get else None

        def __enter__(self):
            if self.item is None:
                self.item = self._queue.get()
            return self.item

        def __exit__(self, Type, value, traceback):
            if self.item is not None:
                self._queue.put(self.item)
                self.item = None

        def __del__(self):
            if self.item is not None:
                self._queue.put(self.item)
                self.item = None


    def main():
        try:
            import queue
        except ImportError:  # python 2.x compatibility
            import Queue as queue

        def test_object(queue):
            pool = ObjectPool(queue, True)
            print('Inside func: {}'.format(pool.item))

        sample_queue = queue.Queue()

        sample_queue.put('yam')
        with ObjectPool(sample_queue) as obj:
            print('Inside with: {}'.format(obj))
        print('Outside with: {}'.format(sample_queue.get()))

        sample_queue.put('sam')
        test_object(sample_queue)
        print('Outside func: {}'.format(sample_queue.get()))

        if not sample_queue.empty():
            print(sample_queue.get())


    if __name__ == '__main__':
        main()
  #+END_SRC

* 输出
  #+BEGIN_EXAMPLE
    ### OUTPUT ###
    # Inside with: yam
    # Outside with: yam
    # Inside func: sam
    # Outside func: sam
  #+END_EXAMPLE

* 理解
  *对象池模式* 是一个很好理解的模式， 用于创建一个对象的代价高昂且经常创建， 但每次
  只使用少数几个的情况。

  *对象池* 可以包含一组已经初始化的对象， 在需要的时候取得或创建对象， 不需要的时候放回或销毁对象。

  示例代码使用 *队列* 来保存这些对象， 外部调用者使用对象池的 ~item~ 属性来访问这些对象。
  
  这一点的实现需要一个 *全局队列* 来保存这些实例， 否则每次调用 ~ObjectPool~ 都会创建一个实例，
  意义就不大了。

  当然， 好处就是在可以在不同的地方使用不同的 *全局队列* 来保存不同类型的对象。

  #+BEGIN_SRC python
    # -*- coding: utf-8 -*-

    try:
        import queue
    except ImportError:
        import Queue as queue


    def create_object_pool():
        class ObjectPool(object):
            _queue = queue.Queue()

            def __init__(self, auto_get=False):
                self.item = ObjectPool.get() if auto_get else None

            @classmethod
            def get(cls):
                return cls._queue.get()

            @classmethod
            def put(cls, obj):
                cls._queue.put(obj)

            @classmethod
            def empty(cls):
                return cls._queue.empty()

            def __enter__(self):
                if self.item is None:
                    self.item = ObjectPool.get()
                return self.item

            def __exit__(self, Type, value, traceback):
                if self.item is not None:
                    ObjectPool.put(self.item)
                    self.item = None

            def __del__(self):
                if self.item is not None:
                    ObjectPool.put(self.item)
                    self.item = None

        return ObjectPool


    if __name__ == '__main__':
        def test_object():
            pool = ObjectPool(True)
            print('Inside func: {}'.format(pool.item))

        ObjectPool = create_object_pool()

        ObjectPool.put('yam')
        with ObjectPool() as obj:
            print('Inside with: {}'.format(obj))
        print('Outside with: {}'.format(ObjectPool.get()))

        ObjectPool.put('sam')
        test_object()
        print('Outside func: {}'.format(ObjectPool.get()))

        if not ObjectPool.empty():
            print(ObjectPool.get())
  #+END_SRC

  执行结果：
  #+BEGIN_EXAMPLE
    Inside with: yam
    Outside with: yam
    Inside func: sam
    Outside func: sam
  #+END_EXAMPLE

