#+TITLE:      builder
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#文档][文档]]
- [[#代码][代码]]
- [[#输出][输出]]
- [[#理解][理解]]

* 文档
  #+BEGIN_SRC python
    """
    *What is this pattern about?
    It decouples the creation of a complex object and its representation,
    so that the same process can be reused to build objects from the same
    family.
    This is useful when you must separate the specification of an object
    from its actual representation (generally for abstraction).

    *What does this example do?

    The first example achieves this by using an abstract base
    class for a building, where the initializer (__init__ method) specifies the
    steps needed, and the concrete subclasses implement these steps.

    In other programming languages, a more complex arrangement is sometimes
    necessary. In particular, you cannot have polymorphic behaviour in a
    constructor in C++ - see https://stackoverflow.com/questions/1453131/how-can-i-get-polymorphic-behavior-in-a-c-constructor
    - which means this Python technique will not work. The polymorphism
    required has to be provided by an external, already constructed
    instance of a different class.

    In general, in Python this won't be necessary, but a second example showing
    this kind of arrangement is also included.

    *Where is the pattern used practically?

    *References:
    https://sourcemaking.com/design_patterns/builder

    *TL;DR80
    Decouples the creation of a complex object and its representation.
    """
  #+END_SRC
  
  *References*:
  + https://sourcemaking.com/design_patterns/builder

* 代码
  #+BEGIN_SRC python
    # Abstract Building
    class Building(object):

        def __init__(self):
            self.build_floor()
            self.build_size()

        def build_floor(self):
            raise NotImplementedError

        def build_size(self):
            raise NotImplementedError

        def __repr__(self):
            return 'Floor: {0.floor} | Size: {0.size}'.format(self)


    # Concrete Buildings
    class House(Building):

        def build_floor(self):
            self.floor = 'One'

        def build_size(self):
            self.size = 'Big'


    class Flat(Building):

        def build_floor(self):
            self.floor = 'More than One'

        def build_size(self):
            self.size = 'Small'


    # In some very complex cases, it might be desirable to pull out the building
    # logic into another function (or a method on another class), rather than being
    # in the base class '__init__'. (This leaves you in the strange situation where
    # a concrete class does not have a useful constructor)


    class ComplexBuilding(object):
        def __repr__(self):
            return 'Floor: {0.floor} | Size: {0.size}'.format(self)


    class ComplexHouse(ComplexBuilding):
        def build_floor(self):
            self.floor = 'One'

        def build_size(self):
            self.size = 'Big and fancy'


    def construct_building(cls):
        building = cls()
        building.build_floor()
        building.build_size()
        return building


    # Client
    if __name__ == "__main__":
        house = House()
        print(house)
        flat = Flat()
        print(flat)

        # Using an external constructor function:
        complex_house = construct_building(ComplexHouse)
        print(complex_house)
  #+END_SRC
  
* 输出
  #+BEGIN_EXAMPLE
    ### OUTPUT ###
    # Floor: One | Size: Big
    # Floor: More than One | Size: Small
    # Floor: One | Size: Big and fancy

  #+END_EXAMPLE
  
* 理解
  维基百科中建造者模式的名字是生成器模式， 当然名字都是小问题。

  建造者模式的理解比前两个模式要困难不少， 也许是抽象的对象有所区别的原因。

  之前的两个模式的抽象针对的都是对象本身， 而建造者模式的抽象在一定程度上抽象的
  是构建对象的 *过程*.

  通过维基百科， 可以看到建造者模式中主要由四部分组成：
  + Builder: 通常为定义实际建造者需要实现的方法的 *抽象类*
  + ConcreteBuilder: 实际建造者， 继承自 Builder
  + Director: 操作 Builder 的接口， 通过 Director 来建造对象
  + Product: 需要被建造的复杂对象

  一般的调用流程为：
  1. 定义 Product, Product 中的部分内容将会由建造者来建造
  2. 定义 Builer, Builer 是一个抽象类， 定义了实际建造者必须要实现的方法
  3. 定义 ConcreteBuilder, 可能有多个， 是实际用来建造 Product 建造者
  4. 定义 Director, 定义可以用来设置 Product 和 ConcreteBuilder 的接口， 同时
     还要定义使用建造者的接口
  5. 定义 Director 实例， 设置实例的 Product 和 ConcreteBuilder, 使用建造者接口
     建造并获取对象

  很明显， 整个建造者模式并不简单， 因此不适合在构建简单的对象的时候使用。

  建造者模式的实现离不开 *抽象类*, 示例代码中 *抽象类* 实现算是一种在 ~Python~ 中实现
  *抽象类* 的一种方式， 当然， 我觉得还可以有其他方法：

  #+BEGIN_SRC python
    # -*- coding: utf-8 -*-

    from abc import ABCMeta, abstractmethod
    from six import with_metaclass


    # Product
    class Product(object):
        def __init__(self):
            self.floor = None
            self.size = None

        def __repr__(self):
            return 'Floor: {0.floor} | Size: {0.size}'.format(self)


    # Abstract Building
    class Building(with_metaclass(ABCMeta, object)):
        def __init__(self):
            self.product = None

        def create_new_product(self):
            self.product = Product()

        @abstractmethod
        def build_floor(self):
            pass

        @abstractmethod
        def build_size(self):
            pass


    # Concrete Building
    class House(Building):
        def build_floor(self):
            self.product.floor = 'One'

        def build_size(self):
            self.product.size = 'Big'


    class Flat(Building):
        def build_floor(self):
            self.product.floor = 'More than One'

        def build_size(self):
            self.product.size = 'Small'


    # Director
    class Director(object):
        def __init__(self):
            self.builder = None

        def set_builder(self, builder):
            self.builder = builder

        def get_product(self):
            return self.builder.product

        def construct_product(self):
            self.builder.create_new_product()
            self.builder.build_floor()
            self.builder.build_size()


    if __name__ == '__main__':
        director = Director()

        house = House()
        Flat = Flat()

        director.set_builder(house)
        director.construct_product()
        print(director.get_product())
  #+END_SRC

  执行结果：
  #+BEGIN_EXAMPLE
    Floor: One | Size: Big
  #+END_EXAMPLE

