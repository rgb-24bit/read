#+TITLE:      abstract factory
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#文档][文档]]
- [[#代码][代码]]
- [[#输出][输出]]
- [[#理解][理解]]

* 文档
  #+BEGIN_SRC python
    """
    *What is this pattern about?

    In Java and other languages, the Abstract Factory Pattern serves to provide an interface for
    creating related/dependent objects without need to specify their
    actual class.

    The idea is to abstract the creation of objects depending on business
    logic, platform choice, etc.

    In Python, the interface we use is simply a callable, which is "builtin" interface
    in Python, and in normal circumstances we can simply use the class itself as
    that callable, because classes are first class objects in Python.

    *What does this example do?
    This particular implementation abstracts the creation of a pet and
    does so depending on the factory we chose (Dog or Cat, or random_animal)
    This works because both Dog/Cat and random_animal respect a common
    interface (callable for creation and .speak()).
    Now my application can create pets abstractly and decide later,
    based on my own criteria, dogs over cats.

    *Where is the pattern used practically?

    *References:
    https://sourcemaking.com/design_patterns/abstract_factory
    http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/

    *TL;DR80
    Provides a way to encapsulate a group of individual factories.
    """
  #+END_SRC

  *References*:
  + https://sourcemaking.com/design_patterns/abstract_factory
  + http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/

* 代码
  #+BEGIN_SRC python
    # -*- coding: utf-8 -*-

    import random


    class PetShop(object):

        """A pet shop"""

        def __init__(self, animal_factory=None):
            """pet_factory is our abstract factory.  We can set it at will."""

            self.pet_factory = animal_factory

        def show_pet(self):
            """Creates and shows a pet using the abstract factory"""

            pet = self.pet_factory()
            print("We have a lovely {}".format(pet))
            print("It says {}".format(pet.speak()))


    class Dog(object):

        def speak(self):
            return "woof"

        def __str__(self):
            return "Dog"


    class Cat(object):

        def speak(self):
            return "meow"

        def __str__(self):
            return "Cat"


    # Additional factories:

    # Create a random animal
    def random_animal():
        """Let's be dynamic!"""
        return random.choice([Dog, Cat])()


    # Show pets with various factories
    if __name__ == "__main__":

        # A Shop that sells only cats
        cat_shop = PetShop(Cat)
        cat_shop.show_pet()
        print("")

        # A shop that sells random animals
        shop = PetShop(random_animal)
        for i in range(3):
            shop.show_pet()
            print("=" * 20)
  #+END_SRC

* 输出
  #+BEGIN_EXAMPLE
    ### OUTPUT ###
    # We have a lovely Cat
    # It says meow
    # 
    # We have a lovely Dog
    # It says woof
    # ====================
    # We have a lovely Cat
    # It says meow
    # ====================
    # We have a lovely Cat
    # It says meow
    # ====================
  #+END_EXAMPLE

* 理解
  抽象工厂模式的定义是： 提供接口，创建一系列相关或独立的对象，而不指定这些对象的具体类。

  通过定义可以了解到， 抽象工厂模式向调用者隐藏了具体类的细节， 调用者只需要在需要的时候
  以适当的方式调用接口， 便可以获得需要的对象。

  同时， 这样的方式在扩展工厂的时候调用者不需要对代码做出太多修改， 只需要在调用时适当的修改
  调用方式即可。

  这个模式要在 Python 中实现是很容易的， 除了示例代码的方式， 我想只要是能够返回对象的可调用对象
  都可以用来充当这个工厂。

  #+BEGIN_SRC python
    # -*- coding: utf-8 -*-

    def create_repository(vc_type, path):
        """abstract factory used to create repository."""
        vc = {'git': Git, 'svn': Svn}
        return vc[vc_type](path)


    class Git(object):
        def __init__(self, path):
            self.path = path

        def __repr__(self):
            return 'git repository: ' + self.path


    class Svn(object):
        def __init__(self, path):
            self.path = path

        def __repr__(self):
            return 'svn repository: ' + self.path


    if __name__ == '__main__':
        repository = create_repository('git', '~/abstract-factory')
        print(repository)

        repository = create_repository('svn', '~/abstract-factory')
        print(repository)
  #+END_SRC

  执行结果：
  #+BEGIN_EXAMPLE
    git repository: ~/abstract-factory
    svn repository: ~/abstract-factory
  #+END_EXAMPLE

