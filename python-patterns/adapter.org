#+TITLE:      adapter
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#文档][文档]]
- [[#代码][代码]]
- [[#输出][输出]]
- [[#理解][理解]]

* 文档
  #+BEGIN_SRC python
    """
    *What is this pattern about?
    The Adapter pattern provides a different interface for a class. We can
    think about it as a cable adapter that allows you to charge a phone
    somewhere that has outlets in a different shape. Following this idea,
    the Adapter pattern is useful to integrate classes that couldn't be
    integrated due to their incompatible interfaces.

    *What does this example do?

    The example has classes that represent entities (Dog, Cat, Human, Car)
    that make different noises. The Adapter class provides a different
    interface to the original methods that make such noises. So the
    original interfaces (e.g., bark and meow) are available under a
    different name: make_noise.

    *Where is the pattern used practically?
    The Grok framework uses adapters to make objects work with a
    particular API without modifying the objects themselves:
    http://grok.zope.org/doc/current/grok_overview.html#adapters

    *References:
    http://ginstrom.com/scribbles/2008/11/06/generic-adapter-class-in-python/
    https://sourcemaking.com/design_patterns/adapter
    http://python-3-patterns-idioms-test.readthedocs.io/en/latest/ChangeInterface.html#adapter

    *TL;DR80
    Allows the interface of an existing class to be used as another interface.
    """
  #+END_SRC
  
  *References*:
  + http://ginstrom.com/scribbles/2008/11/06/generic-adapter-class-in-python/
  + https://sourcemaking.com/design_patterns/adapter
  + http://python-3-patterns-idioms-test.readthedocs.io/en/latest/ChangeInterface.html#adapter

* 代码
  #+BEGIN_SRC python
    class Dog(object):

        def __init__(self):
            self.name = "Dog"

        def bark(self):
            return "woof!"


    class Cat(object):

        def __init__(self):
            self.name = "Cat"

        def meow(self):
            return "meow!"


    class Human(object):

        def __init__(self):
            self.name = "Human"

        def speak(self):
            return "'hello'"


    class Car(object):

        def __init__(self):
            self.name = "Car"

        def make_noise(self, octane_level):
            return "vroom{0}".format("!" * octane_level)


    class Adapter(object):
        """
        Adapts an object by replacing methods.
        Usage:
        dog = Dog()
        dog = Adapter(dog, make_noise=dog.bark)

        >>> objects = []
        >>> dog = Dog()
        >>> print(dog.__dict__)
        {'name': 'Dog'}
        >>> objects.append(Adapter(dog, make_noise=dog.bark))
        >>> print(objects[0].original_dict())
        {'name': 'Dog'}
        >>> cat = Cat()
        >>> objects.append(Adapter(cat, make_noise=cat.meow))
        >>> human = Human()
        >>> objects.append(Adapter(human, make_noise=human.speak))
        >>> car = Car()
        >>> car_noise = lambda: car.make_noise(3)
        >>> objects.append(Adapter(car, make_noise=car_noise))

        >>> for obj in objects:
        ...     print('A {} goes {}'.format(obj.name, obj.make_noise()))
        A Dog goes woof!
        A Cat goes meow!
        A Human goes 'hello'
        A Car goes vroom!!!
        """

        def __init__(self, obj, **adapted_methods):
            """We set the adapted methods in the object's dict"""
            self.obj = obj
            self.__dict__.update(adapted_methods)

        def __getattr__(self, attr):
            """All non-adapted calls are passed to the object"""
            return getattr(self.obj, attr)

        def original_dict(self):
            """Print original object dict"""
            return self.obj.__dict__

    def main():

        objects = []
        dog = Dog()
        print(dog.__dict__)
        objects.append(Adapter(dog, make_noise=dog.bark))
        print(objects[0].__dict__)
        print(objects[0].original_dict())
        cat = Cat()
        objects.append(Adapter(cat, make_noise=cat.meow))
        human = Human()
        objects.append(Adapter(human, make_noise=human.speak))
        car = Car()
        objects.append(Adapter(car, make_noise=lambda: car.make_noise(3)))

        for obj in objects:
            print("A {0} goes {1}".format(obj.name, obj.make_noise()))


    if __name__ == "__main__":
        main()
  #+END_SRC

* 输出
  #+BEGIN_EXAMPLE
    ### OUTPUT ###
    # {'name': 'Dog'}
    # {'make_noise': <bound method Dog.bark of <__main__.Dog object at 0x7f631ba3fb00>>, 'obj': <__main__.Dog object at 0x7f631ba3fb00>}
    # {'name': 'Dog'}
    # A Dog goes woof!
    # A Cat goes meow!
    # A Human goes 'hello'
    # A Car goes vroom!!!
  #+END_EXAMPLE

* 理解
  *适配器模式* 是一个挺有用的模式， 可以将不同的接口转换为统一的接口。

  假设已有一个软件系统， 希望可以和一个新的厂商类库搭配使用， 但是这个新厂商设计的接口和旧厂商的
  接口不一样。

  如果不想修改现有的代码， 那么就可以编写一个类， 将接口转接成期望的接口。

  如同示例代码， ~Dog~, ~Cat~, ~Human~, ~Car~ 的接口互不相同， 但是通过适配器 ~Adapter~ 转换后， 这些
  对象都具有了统一的接口 ~make_noise~.

  *适配器模式* 有两种实现方式， 一种是 *对象适配器*, 一种是 *类适配器*.

  + *对象适配器* 容纳一个它包裹的类的实例， 适配器调用被包裹对象的物理实体， 如同示例代码

  + *类适配器* 通过继承自己实现的类来达到适配效果

  #+BEGIN_SRC python
    # -*- coding: utf-8 -*-

    """
    Class Adapter pattern example.
    """

    from abc import ABCMeta, abstractmethod
    from six import with_metaclass


    NOT_IMPLEMENTED = "You should implement this."

    RECHARGE = ["Recharge started.", "Recharge finished."]

    POWER_ADAPTERS = {"Android": "MicroUSB", "iPhone": "Lightning"}

    CONNECTED = "{} connected."
    CONNECT_FIRST = "Connect {} first."


    class RechargeTemplate(with_metaclass(ABCMeta, object)):
        @abstractmethod
        def recharge(self):
            raise NotImplementedError(NOT_IMPLEMENTED)


    class FormatIPhone(RechargeTemplate):
        @abstractmethod
        def use_lightning(self):
            raise NotImplementedError(NOT_IMPLEMENTED)


    class FormatAndroid(RechargeTemplate):
        @abstractmethod
        def use_micro_usb(self):
            raise NotImplementedError(NOT_IMPLEMENTED)


    class IPhone(FormatIPhone):
        __name__ = "iPhone"

        def __init__(self):
            self.connector = False

        def use_lightning(self):
            self.connector = True
            print(CONNECTED.format(POWER_ADAPTERS[self.__name__]))

        def recharge(self):
            if self.connector:
                for state in RECHARGE:
                    print(state)
            else:
                print(CONNECT_FIRST.format(POWER_ADAPTERS[self.__name__]))


    class Android(FormatAndroid):
        __name__ = "Android"

        def __init__(self):
            self.connector = False

        def use_micro_usb(self):
            self.connector = True
            print(CONNECTED.format(POWER_ADAPTERS[self.__name__]))

        def recharge(self):
            if self.connector:
                for state in RECHARGE:
                    print(state)
            else:
                print(CONNECT_FIRST.format(POWER_ADAPTERS[self.__name__]))


    class IPhoneAdapter(FormatAndroid):
        def __init__(self, mobile):
            self.mobile = mobile

        def recharge(self):
            self.mobile.recharge()

        def use_micro_usb(self):
            print(CONNECTED.format(POWER_ADAPTERS["Android"]))
            self.mobile.use_lightning()


    class AndroidRecharger(object):
        def __init__(self):
            self.phone = Android()
            self.phone.use_micro_usb()
            self.phone.recharge()


    class IPhoneMicroUSBRecharger(object):
        def __init__(self):
            self.phone = IPhone()
            self.phone_adapter = IPhoneAdapter(self.phone)
            self.phone_adapter.use_micro_usb()
            self.phone_adapter.recharge()


    class IPhoneRecharger(object):
        def __init__(self):
            self.phone = IPhone()
            self.phone.use_lightning()
            self.phone.recharge()


    if __name__ == '__main__':
        print("Recharging Android with MicroUSB recharger.")
        AndroidRecharger()
        print()


        print("Recharging iPhone with MicroUSB using adapter pattern.")
        IPhoneMicroUSBRecharger()
        print()


        print("Recharging iPhone with iPhone recharger.")
        IPhoneRecharger()
  #+END_SRC

  执行结果：
  #+BEGIN_EXAMPLE
    Recharging Android with MicroUSB recharger.
    MicroUSB connected.
    Recharge started.
    Recharge finished.

    Recharging iPhone with MicroUSB using adapter pattern.
    MicroUSB connected.
    Lightning connected.
    Recharge started.
    Recharge finished.

    Recharging iPhone with iPhone recharger.
    Lightning connected.
    Recharge started.
    Recharge finished.
  #+END_EXAMPLE

