#+TITLE:      decorator
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#文档][文档]]
- [[#代码][代码]]
- [[#输出][输出]]
- [[#理解][理解]]

* 文档
  #+BEGIN_SRC python
    """
    *What is this pattern about?
    The Decorator pattern is used to dynamically add a new feature to an
    object without changing its implementation. It differs from
    inheritance because the new feature is added only to that particular
    object, not to the entire subclass.

    *What does this example do?
    This example shows a way to add formatting options (boldface and
    italic) to a text by appending the corresponding tags (<b> and
    <i>). Also, we can see that decorators can be applied one after the other,
    since the original text is passed to the bold wrapper, which in turn
    is passed to the italic wrapper.

    *Where is the pattern used practically?
    The Grok framework uses decorators to add functionalities to methods,
    like permissions or subscription to an event:
    http://grok.zope.org/doc/current/reference/decorators.html

    *References:
    https://sourcemaking.com/design_patterns/decorator

    *TL;DR80
    Adds behaviour to object without affecting its class.
    """
  #+END_SRC
  
  *References*:
  + https://sourcemaking.com/design_patterns/decorator

* 代码
  #+BEGIN_SRC python
    from __future__ import print_function

    class TextTag(object):
        """Represents a base text tag"""
        def __init__(self, text):
            self._text = text

        def render(self):
            return self._text


    class BoldWrapper(TextTag):
        """Wraps a tag in <b>"""
        def __init__(self, wrapped):
            self._wrapped = wrapped

        def render(self):
            return "<b>{}</b>".format(self._wrapped.render())


    class ItalicWrapper(TextTag):
        """Wraps a tag in <i>"""
        def __init__(self, wrapped):
            self._wrapped = wrapped

        def render(self):
            return "<i>{}</i>".format(self._wrapped.render())

    if __name__ == '__main__':
        simple_hello = TextTag("hello, world!")
        special_hello = ItalicWrapper(BoldWrapper(simple_hello))
        print("before:", simple_hello.render())
        print("after:", special_hello.render())
  #+END_SRC

* 输出
  #+BEGIN_EXAMPLE
    ### OUTPUT ###
    # before: hello, world!
    # after: <i><b>hello, world!</b></i>
  #+END_EXAMPLE

* 理解
  *装饰者模式* 可以在运行时扩充一个类的功能， *装饰类* 应该和原有的类具有 *相同* 的接口。

  一般的继承用于添加 *新功能*, 而装饰类对原有的功能进行扩展。

  如同示例代码， 在需要装饰的时候， 使用装饰类对原有的类对象进行装饰。 因为相互之间的接口相同， 因此
  可以多重装饰。

  #+BEGIN_SRC python
    # -*- coding: utf-8 -*-

    class TextTag(object):
        """Represents a base text tag"""
        def __init__(self, text):
            self._text = text

        def render(self):
            return self._text


    class BoldWrapper(TextTag):
        """Wraps a tag in <b>"""
        def __init__(self, wrapped):
            self._wrapped = wrapped

        def render(self):
            return "<b>{}</b>".format(self._wrapped.render())


    class ItalicWrapper(TextTag):
        """Wraps a tag in <i>"""
        def __init__(self, wrapped):
            self._wrapped = wrapped

        def render(self):
            return "<i>{}</i>".format(self._wrapped.render())


    class UnderlineWarpper(TextTag):
        """Wraps a tag in <u>"""
        def __init__(self, wrapped):
            self._wrapped = wrapped

        def render(self):
            return "<u>{}</u>".format(self._wrapped.render())


    if __name__ == '__main__':
        simple_hello = TextTag("hello, world!")
        special_hello = UnderlineWarpper(ItalicWrapper(BoldWrapper(simple_hello)))
        print("before:", simple_hello.render())
        print("after:", special_hello.render())
  #+END_SRC

  执行结果：
  #+BEGIN_EXAMPLE
    before: hello, world!
    after: <u><i><b>hello, world!</b></i></u>
  #+END_EXAMPLE

