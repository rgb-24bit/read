#+TITLE:      utilities
#+AUTHOR:     rgb-24bit
#+EMAIL:      rgb-24bit@foxmail.com

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#contextmanager][contextmanager]]
- [[#symbol][symbol]]
- [[#hashable_identity][hashable_identity]]
- [[#reference][reference]]
- [[#lazy_property][lazy_property]]

* contextmanager
  #+BEGIN_SRC python
    try:
        from contextlib import contextmanager
    except ImportError:
        def contextmanager(fn):
            def oops(*args, **kw):
                raise RuntimeError("Python 2.5 or above is required to use "
                                   "context managers.")
            oops.__name__ = fn.__name__
            return oops
  #+END_SRC

  ~contextmanager~ 是一个很有用的 *装饰器*, 可以让我们省去编写 ~__enter__~ 和 ~__exit__~ 的工作。

* symbol
  #+BEGIN_SRC python
    class _symbol(object):

        def __init__(self, name):
            """Construct a new named symbol."""
            self.__name__ = self.name = name

        def __reduce__(self):
            return symbol, (self.name,)

        def __repr__(self):
            return self.name
    _symbol.__name__ = 'symbol'


    class symbol(object):
        """A constant symbol.
        >>> symbol('foo') is symbol('foo')
        True
        >>> symbol('foo')
        foo
        A slight refinement of the MAGICCOOKIE=object() pattern.  The primary
        advantage of symbol() is its repr().  They are also singletons.
        Repeated calls of symbol('name') will all return the same instance.
        """
        symbols = {}

        def __new__(cls, name):
            try:
                return cls.symbols[name]
            except KeyError:
                return cls.symbols.setdefault(name, _symbol(name))
  #+END_SRC

  魔法方法 ~__reduce__~ 之前看到过， 和 ~pickle~ 相关， 但由于没有接触过相关概念， 所以没在意。

  今天在看了一下， 发现， ~pickle~ 不就相当于 ~java~ 中的序列化么......

  使用 ~pickle~ 保存一个对象：
  #+BEGIN_SRC python
    import pickle

    data = {'foo': [1,2,3],
                    'bar': ('Hello', 'world!'),
                    'baz': True}
    jar = open('data.pkl', 'wb')
    pickle.dump(data, jar)
    jar.close()
  #+END_SRC

  还原对象：
  #+BEGIN_SRC python
    import pickle

    pkl_file = open('data.pkl', 'rb') 
    data = pickle.load(pkl_file) 
    print data
    pkl_file.close()
  #+END_SRC

  详细了解： [[http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#pickle][Pickle 你的对象]]

  除此之外的代码还是比较简单的， 使用相同参数实例化 ~symbol~ 会返回同一个对象。

* hashable_identity
  #+BEGIN_SRC python
    try:
        text = (str, unicode)
    except NameError:
        text = str


    def hashable_identity(obj):
        if hasattr(obj, '__func__'):
            return (id(obj.__func__), id(obj.__self__))
        elif hasattr(obj, 'im_func'):
            return (id(obj.im_func), id(obj.im_self))
        elif isinstance(obj, text):
            return obj
        else:
            return id(obj)
  #+END_SRC

  这个函数主要还是需要看在什么地方使用了， 但是暂时还没有看到使用的地方 @_@

* reference
  #+BEGIN_SRC python
    class annotatable_weakref(ref):
        """A weakref.ref that supports custom instance attributes."""


    def reference(object, callback=None, **annotations):
        """Return an annotated weak ref."""
        if callable(object):
            weak = callable_reference(object, callback)
        else:
            weak = annotatable_weakref(object, callback)
        for key, value in annotations.items():
            setattr(weak, key, value)
        return weak


    def callable_reference(object, callback=None):
        """Return an annotated weak ref, supporting bound instance methods."""
        if hasattr(object, 'im_self') and object.im_self is not None:
            return BoundMethodWeakref(target=object, on_delete=callback)
        elif hasattr(object, '__self__') and object.__self__ is not None:
            return BoundMethodWeakref(target=object, on_delete=callback)
        return annotatable_weakref(object, callback)
  #+END_SRC

  emmmm, 所以 ~_saferef~ 中的 ~saferef~ 是干啥的 ？

  不过这一段的代码确实比 ~saferef~ 耐看。

  ~annotatable_weakref~ 继承一下 ~ref~ 然后就可以随便设置属性了， 还行。

* lazy_property
  #+BEGIN_SRC python
    class lazy_property(object):
        """A @property that is only evaluated once."""

        def __init__(self, deferred):
            self._deferred = deferred
            self.__doc__ = deferred.__doc__

        def __get__(self, obj, cls):
            if obj is None:
                return self
            value = self._deferred(obj)
            setattr(obj, self._deferred.__name__, value)
            return value
  #+END_SRC

  这个貌似就是我之前看的 *惰性求值*, 因为用到了描述器， 当时把我绕的啊......

  使用 ~lazy_property~ 装饰一个方法， 这个方法其实是一个属性， 当获取这个属性时才计算该属性的值，
  然后通过 ~setattr~ 将值赋给该属性。 之后就不进行求值运算。

